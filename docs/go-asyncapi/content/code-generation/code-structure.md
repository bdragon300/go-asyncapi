+++
title = 'Code structure'
weight = 400
description = 'Generated code structure overview and explanation'
+++

# Generated code design

The code generated by `go-asyncapi` roughly follows the AsyncAPI specification structure, but it is not a 1:1 mapping.
On the figure below it's shown what the code looks like from high level.

{{< figure src="images/code-overview.svg" alt="Code structure overview" >}}

The structure of types is shown below.

{{< figure src="images/code-types.svg" alt="Types structure diagram" >}}

Roughly speaking, the generated code consists of several parts:

* Go types that are generated separately for every protocol it is bound to (channel, operation, etc.)
* Go types that are generated once (message, model, etc.)
* Implementation code for every protocol used in the AsyncAPI document

This reminds the [Bridge pattern](https://en.wikipedia.org/wiki/Bridge_pattern). It has an abstraction layer,
that follows the AsyncAPI entities, and an implementation layer, that can be selected from the built-in implementations
in tool's configuration or be provided by the user. These layers are isolated from each other via Go interfaces.

Let's take a look what these objects are for:

* **Server**. Keeps the information defined in document (bindings, URL, etc.) 
to open channels\operations to this server. The Server implements only one protocol.
* **Channel**. It is used to send\receive envelopes 
using protocol publisher\subscriber, and to seal a protocol-agnostic message into a protocol-specific envelope and back.
One type per protocol of every server the Channel bounds to, keeping the information defined in document 
(bindings, parameters, etc.).
* **Operation**. In fact, this is a wrapper around the Channel implementing 
a part of its functionality, but with Operation-specific logic in opening and message handling. 
One type per protocol of every server the Operation bounds to, keeping the information defined in document 
(bindings, bound messages, etc.).
* **Message**. Protocol-agnostic message with payload data, metadata, etc.
Implements the marshalling/unmarshalling logic to\from Envelopes of every protocol it is bound to. Also, Message keeps
the information defined in document (bindings, etc.).
* **Schema**. is a general purpose type crafted from
[jsonschema](https://json-schema.org/) defined in `components.schemas` AsyncAPI section. Can be referred by any other entity.

{{% hint info %}}
**Server**, **Channel**, **Operation** and **Message** may be declared in root section of the AsyncAPI document (e.g. `servers`)
and in the `components` section (e.g. `components.servers`).

The code generates only for the first case. `components` section defines reusable parts, so produces the code only when 
these parts are referenced, otherwise they are ignored.
{{% /hint %}}

Every Implementation has its own set of types, that are used to interact with the message broker. There are:

* **Producer/Consumer**. Represents the network connection to the message broker, but not used to send or receive messages.
The main purpose is to open Publisher/Subscriber within an opened connection.
* **Publisher/Subscriber**. Represents a data channel inside a network connection. It is used to send and receive messages
* **Envelope**. A Message marshalled into a protocol data. Usually, Envelope is the concrete Go struct, that represents a 
message in an Implementation library.

{{% hint info %}}
The reason of separating the connection creation and channel creation process is the fact, that some protocols 
(like Kafka) allow to open multiple channels (produce/consume topics) within a single connection or a client object. 
Other protocols (like WebSocket) treat a connection as a channel. Moreover, different libraries for the same protocol 
may have their own specifics in how they open channels and connections.

So, this approach helps to abstract from these details.
{{% /hint %}}
