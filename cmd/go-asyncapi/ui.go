package main

import (
	"bytes"
	"fmt"
	"io"
	"io/fs"
	"net/http"
	"os"
	"path"
	"strings"

	"github.com/bdragon300/go-asyncapi/internal/common"
	"github.com/bdragon300/go-asyncapi/internal/compiler"
	"github.com/bdragon300/go-asyncapi/internal/jsonpointer"
	"github.com/bdragon300/go-asyncapi/internal/log"
	"github.com/bdragon300/go-asyncapi/internal/renderer"
	"github.com/bdragon300/go-asyncapi/internal/tmpl"
	"github.com/bdragon300/go-asyncapi/internal/tmpl/manager"
	"github.com/bdragon300/go-asyncapi/templates/ui"
	"github.com/samber/lo"
)

const (
	defaultUIOutputFileExtension = ".html"
)

var builtinUIResourceURLs = []string{
	"https://unpkg.com/@asyncapi/react-component@latest/styles/default.min.css",
	"https://unpkg.com/@asyncapi/react-component@latest/browser/standalone/index.js",
}

type UICmd struct {
	Document string `arg:"required,positional" help:"AsyncAPI document file or url" placeholder:"FILE"`

	Output        string `arg:"-o,--output" help:"Output file path. By default, the file name is autogenerated" placeholder:"FILE"`
	Listen        *bool  `arg:"-l,--listen" help:"Start a local server to serve the UI"`
	ListenAddress string `arg:"-a,--listen-address" help:"Address to bind the local server to, default to :8090" placeholder:"ADDRESS"`
	ListenPath    string `arg:"--listen-path" help:"Path to serve the UI at, default to /" placeholder:"PATH"`

	ReferenceOnly *bool  `arg:"--reference-only" help:"Do not embed the document into the html, load it from the passed URL instead"`
	Bundle        *bool  `arg:"--bundle" help:"Bundle 3rd-party JS/CSS resources into the output HTML file"`
	BundleDir     string `arg:"--bundle-dir" help:"Directory with files to bundle instead of built-in ones" placeholder:"DIR"`

	TemplatesDir string `arg:"-T,--templates-dir" help:"User templates directory" placeholder:"DIR"`
}

func cliUI(cmd *UICmd, globalConfig toolConfig) error {
	logger := log.GetLogger("")
	cmdConfig, err := cliUIMergeConfig(globalConfig, cmd)
	if err != nil {
		return fmt.Errorf("config: %w", err)
	}

	if cmdConfig.UI.BundleDir != "" && !lo.FromPtr(cmdConfig.UI.Bundle) {
		return fmt.Errorf("ui bundle directory is set but bundling is disabled. Use --bundle flag to enable bundling")
	}

	locator := getLocator(cmdConfig)
	docURL, err := jsonpointer.Parse(cmd.Document)
	if err != nil {
		return fmt.Errorf("parse URL: %w", err)
	}

	//
	// Parsing the document
	//
	rawDocument := make(map[string]any)
	if lo.FromPtr(cmdConfig.UI.ReferenceOnly) {
		if docURL.URI == nil {
			return fmt.Errorf("document path must be an URL")
		}
	} else {
		logger.Debug("Reading the file", "path", cmd.Document)
		buf, newDecoder, err := compiler.ReadDocument(docURL, locator, logger)
		if err != nil {
			return fmt.Errorf("read document: %w", err)
		}
		if err = newDecoder(bytes.NewReader(buf)).Decode(&rawDocument); err != nil {
			return fmt.Errorf("decode document: %w", err)
		}
	}

	//
	// Rendering
	//
	logger.Debug("Run template rendering")
	renderManager := manager.NewTemplateRenderManager(common.RenderOpts{})
	templateDirs := []fs.FS{ui.TemplateFS}
	if cmdConfig.Code.TemplatesDir != "" {
		logger.Debug("Custom templates location", "directory", cmdConfig.Code.TemplatesDir)
		templateDirs = append(templateDirs, os.DirFS(cmdConfig.Code.TemplatesDir))
	}
	tplLoader := tmpl.NewTemplateLoader(defaultMainTemplateName, templateDirs...)
	logger.Trace("Parse templates", "dirs", templateDirs)
	renderManager.TemplateLoader = tplLoader
	if err = tplLoader.ParseRecursive(renderManager); err != nil {
		return fmt.Errorf("parse templates: %w", err)
	}
	fileName := cmdConfig.UI.OutputFile
	if fileName == "" {
		fileName = strings.TrimSuffix(path.Base(cmd.Document), path.Ext(cmd.Document)) + defaultUIOutputFileExtension
	}
	uiConfig := getUIConfig(cmdConfig.UI)

	var resourceContents [][]byte
	resourceLocations := builtinUIResourceURLs
	if lo.FromPtr(cmdConfig.UI.Bundle) {
		if cmdConfig.UI.BundleDir != "" {
			logger.Debug("Gathering resources from directory", "directory", cmdConfig.UI.BundleDir)
			if resourceLocations, err = listDirectoryFiles(cmdConfig.UI.BundleDir); err != nil {
				return fmt.Errorf("gather resources from dir: %w", err)
			}
		}
		logger.Debug("Reading resources for bundling", "locations", resourceLocations)
		resourceContents, err = readUIResources(resourceLocations)
		if err != nil {
			return fmt.Errorf("download resources: %w", err)
		}
	}

	var urlBase string
	if lo.FromPtr(cmdConfig.UI.Bundle) && lo.FromPtr(cmdConfig.UI.Listen) {
		urlBase = "." // relative path for bundled resources
	}
	embedResources := lo.FromPtr(cmdConfig.UI.Bundle) && !lo.FromPtr(cmdConfig.UI.Listen) // embed only in non-serving mode
	uiResources, err := buildUIResources(resourceLocations, resourceContents, urlBase, embedResources)
	if err != nil {
		return err
	}
	if err = renderer.RenderUI(docURL, fileName, rawDocument, uiResources, uiConfig, renderManager); err != nil {
		return fmt.Errorf("render ui: %w", err)
	}

	renderState := renderManager.CommittedStates()[fileName]
	if lo.FromPtr(cmdConfig.UI.Listen) {
		logger.Info("Starting HTTP server", "address", cmdConfig.UI.ListenAddress)
		files := map[string]servingUIContent{
			cmdConfig.UI.ListenPath: { // main page
				Contents: renderState.Buffer.Bytes(),
				Headers:  map[string]string{"Content-Type": "text/html; charset=utf-8"},
			},
		}
		// Add bundled resources in bundled mode
		if lo.FromPtr(cmdConfig.UI.Bundle) {
			for _, resource := range uiResources {
				r := servingUIContent{Contents: []byte(resource.Content), Headers: make(map[string]string)}
				switch resource.FileExtension {
				case ".js":
					r.Headers["Content-Type"] = "application/javascript; charset=utf-8"
				case ".css":
					r.Headers["Content-Type"] = "text/css; charset=utf-8"
				default:
					r.Headers["Content-Type"] = "application/octet-stream"
				}
				files[path.Join(cmdConfig.UI.ListenPath, path.Base(resource.Location))] = r
			}
		}
		if err = serveUI(cmdConfig.UI.ListenAddress, files); err != nil {
			return fmt.Errorf("serve http: %w", err)
		}
	} else {
		outputPath := cmdConfig.UI.OutputFile
		if outputPath == "" {
			outputPath = fileName
		}
		logger.Info("Writing output file", "file", outputPath)
		if err = os.WriteFile(outputPath, renderState.Buffer.Bytes(), 0o644); err != nil {
			return fmt.Errorf("write output file %q: %w", outputPath, err)
		}
		logger.Debug("Writing complete")
	}

	return nil
}

func listDirectoryFiles(directory string) ([]string, error) {
	var res []string
	logger := log.GetLogger("")
	dirContents, err := os.ReadDir(directory)
	if err != nil {
		return nil, fmt.Errorf("readdir %q: %w", directory, err)
	}
	for _, entry := range dirContents {
		fullPath := path.Join(directory, entry.Name())
		logger.Trace("Directory entry", "name", fullPath)
		if !entry.Type().IsRegular() {
			logger.Trace("Skipping non-regular entry", "name", fullPath)
			continue
		}
		if strings.HasPrefix(entry.Name(), ".") {
			logger.Debug("Skipping hidden file", "name", fullPath)
			continue
		}
		res = append(res, fullPath)
	}
	return res, nil
}

func readUIResources(locations []string) ([][]byte, error) {
	var resources [][]byte
	var err error
	logger := log.GetLogger("")
	for _, loc := range locations {
		u := lo.Must(jsonpointer.Parse(loc))
		var data []byte
		if u.URI != nil {
			logger.Debug("Downloading UI resource", "uri", u.URI)
			if data, err = downloadUIResource(u.URI.String()); err != nil {
				return nil, fmt.Errorf("http resource %q: %w", u.URI.String(), err)
			}
		} else {
			logger.Debug("Reading UI resource from file", "path", u.FSPath)
			if data, err = os.ReadFile(u.FSPath); err != nil {
				return nil, fmt.Errorf("file resource %q: %w", u.FSPath, err)
			}
		}
		resources = append(resources, data)
	}
	return resources, nil
}

func downloadUIResource(url string) ([]byte, error) {
	resp, err := http.Get(url)
	if err != nil {
		return nil, fmt.Errorf("download resource %q: %w", url, err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("download resource %q: unexpected status code %d", url, resp.StatusCode)
	}

	data, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("read resource data %q: %w", url, err)
	}
	return data, nil
}

func buildUIResources(files []string, contents [][]byte, servePath string, embed bool) ([]common.UIHTMLResourceOpts, error) {
	resources := lo.Map(files, func(srcPath string, ind int) common.UIHTMLResourceOpts {
		u := lo.Must(jsonpointer.Parse(srcPath))
		loc := u.FSPath
		if u.URI != nil {
			loc = u.URI.Path
		}

		r := common.UIHTMLResourceOpts{Location: srcPath, Embed: embed, FileExtension: path.Ext(loc)}
		if servePath != "" {
			r.Location = path.Join(servePath, path.Base(loc))
		}

		if len(contents) > ind && contents[ind] != nil {
			r.Content = string(contents[ind])
		}
		return r
	})
	return resources, nil
}

type servingUIContent struct {
	Contents []byte
	Headers  map[string]string
}

func serveUI(address string, files map[string]servingUIContent) error {
	httpHandler := func(content servingUIContent) http.HandlerFunc {
		return func(w http.ResponseWriter, r *http.Request) {
			logger := log.GetLogger("")
			logger.Debug("HTTP request", "remote", r.RemoteAddr, "method", r.Method, "url", r.RequestURI)
			if r.Method != http.MethodGet {
				logger.Error("Method not allowed", "method", r.Method)
				http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
				return
			}
			for k, vv := range content.Headers {
				w.Header().Set(k, vv)
			}
			if _, err := w.Write(content.Contents); err != nil {
				logger.Error("Write response", "error", err)
				http.Error(w, "Internal server error", http.StatusInternalServerError)
				return
			}
		}
	}

	mux := http.NewServeMux()
	for k, v := range files {
		mux.HandleFunc(k, httpHandler(v))
	}

	srv := http.Server{
		Addr:     address,
		Handler:  mux,
		ErrorLog: log.GetLogger("").StandardLog(),
	}
	if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
		return err
	}
	return nil
}

func cliUIMergeConfig(globalConfig toolConfig, cmd *UICmd) (toolConfig, error) {
	res := globalConfig

	res.UI.OutputFile = coalesce(cmd.Output, globalConfig.UI.OutputFile)
	res.UI.Listen = coalesce(cmd.Listen, globalConfig.UI.Listen)
	res.UI.ListenAddress = coalesce(cmd.ListenAddress, globalConfig.UI.ListenAddress)
	res.UI.ListenPath = coalesce(cmd.ListenPath, globalConfig.UI.ListenPath)
	res.UI.ReferenceOnly = coalesce(cmd.ReferenceOnly, globalConfig.UI.ReferenceOnly)
	res.UI.Bundle = coalesce(cmd.Bundle, globalConfig.UI.Bundle)
	res.UI.BundleDir = coalesce(cmd.BundleDir, globalConfig.UI.BundleDir)

	res.Code.TemplatesDir = coalesce(cmd.TemplatesDir, globalConfig.Code.TemplatesDir)

	return res, nil
}

func getUIConfig(conf toolConfigUI) common.UIRenderOpts {
	return common.UIRenderOpts{ReferenceOnly: lo.FromPtr(conf.ReferenceOnly)}
}
