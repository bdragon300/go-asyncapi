package main

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io/fs"
	"log/slog"
	"os"
	"os/exec"
	"path"
	"slices"
	"strings"
	"time"

	"github.com/bdragon300/go-asyncapi/internal/common"
	"github.com/bdragon300/go-asyncapi/internal/compiler"
	"github.com/bdragon300/go-asyncapi/internal/compiler/compile"
	"github.com/bdragon300/go-asyncapi/internal/jsonpointer"
	"github.com/bdragon300/go-asyncapi/internal/log"
	"github.com/bdragon300/go-asyncapi/internal/renderer"
	"github.com/bdragon300/go-asyncapi/internal/tmpl"
	"github.com/bdragon300/go-asyncapi/internal/tmpl/manager"
	"github.com/bdragon300/go-asyncapi/internal/types"
	"github.com/bdragon300/go-asyncapi/internal/writer"
	"github.com/bdragon300/go-asyncapi/templates/diagram"
	"github.com/samber/lo"
	"oss.terrastruct.com/d2/d2format"
	"oss.terrastruct.com/d2/d2graph"
	"oss.terrastruct.com/d2/d2lib"
	"oss.terrastruct.com/d2/d2plugin"
	"oss.terrastruct.com/d2/d2renderers/d2svg"
	"oss.terrastruct.com/d2/d2target"
	"oss.terrastruct.com/d2/d2themes"
	"oss.terrastruct.com/d2/d2themes/d2themescatalog"
	d2log "oss.terrastruct.com/d2/lib/log"
	"oss.terrastruct.com/d2/lib/textmeasure"
)

type DiagramCmd struct {
	Document          string `arg:"required,positional" help:"AsyncAPI document file or url" placeholder:"FILE"`
	Format            string `arg:"-f,--format" help:"Output diagram format. Possible values: svg, d2" placeholder:"FORMAT"`
	TargetDir         string `arg:"-t,--target-dir" help:"Directory to save the output files" placeholder:"DIR"`
	OutputFile        string `arg:"-o,--output" help:"Output file path. By default, the file name is autogenerated" placeholder:"FILE"`
	MultipleFiles     bool   `arg:"--multiple-files" help:"Generate one diagram file per each source AsyncAPI document instead of all in one diagram. Discards the --output option effect"`
	DisableFormatting bool   `arg:"--disable-formatting" help:"Do not run the d2 file formatter. Only applies when output format is d2"`

	// Styling
	ChannelsCentric bool `arg:"--channels-centric" help:"Generate the channels-centric diagram"`
	ServersCentric  bool `arg:"--servers-centric" help:"Generate the servers-centric diagram"`
	DocumentBorders bool `arg:"--document-borders" help:"Draw document borders in the diagram"`

	DiagramCmdD2Options

	TemplateDir      string        `arg:"-T,--template-dir" help:"User templates directory" placeholder:"DIR"`
	AllowRemoteRefs  bool          `arg:"--allow-remote-refs" help:"Allow locator to fetch the files from remote $ref URLs"`
	LocatorSearchDir string        `arg:"--locator-search-dir" help:"Directory to search the documents for [default: current working directory]" placeholder:"PATH"`
	LocatorTimeout   time.Duration `arg:"--locator-timeout" help:"Timeout for locator to read a document. Format: 30s, 2m, etc." placeholder:"DURATION"`
	LocatorCommand   string        `arg:"--locator-command" help:"Custom locator command to use instead of built-in locator" placeholder:"COMMAND"`
}

type DiagramCmdD2Options struct {
	Engine      string   `arg:"--d2-engine" help:"D2 layout engine to use. Possible values: elk, dagre" placeholder:"NAME"`
	Direction   string   `arg:"--d2-direction" help:"Diagram draw direction. Possible values: up, down, right, left" placeholder:"DIRECTION"`
	ThemeID     *int64   `arg:"--d2-theme-id" help:"Theme ID" placeholder:"ID"`
	DarkThemeID *int64   `arg:"--d2-dark-theme-id" help:"Dark theme ID" placeholder:"ID"`
	Pad         *int64   `arg:"--d2-pad" help:"Diagram padding" placeholder:"PIXELS"`
	Sketch      *bool    `arg:"--d2-sketch" help:"Draw diagram in sketchy style"`
	Center      *bool    `arg:"--d2-center" help:"Center the diagram in the output canvas"`
	Scale       *float64 `arg:"--d2-scale" help:"Scale factor" placeholder:"FACTOR"`

	DiagramCmdD2ELKOptions
	DiagramCmdD2DagreOptions
}

// DiagramCmdD2ELKOptions holds layout options specific to ELK engine.
type DiagramCmdD2ELKOptions struct {
	Algorithm       string `arg:"--d2-elk-algorithm" help:"ELK engine: layout algorithm to use. Possible values: layered, force, radial, mrtree, disco, rectpacking" placeholder:"NAME"`
	NodeSpacing     *int64 `arg:"--d2-elk-node-spacing" help:"ELK engine: spacing to be preserved between any pair of nodes of two adjacent layers" placeholder:"PIXELS"`
	Padding         string `arg:"--d2-elk-padding" help:"ELK engine: expression of padding to be left to a parent element’s border when placing child elements. E.g [top=50,left=50,bottom=50,right=50]" placeholder:"PIXELS"`
	EdgeSpacing     *int64 `arg:"--d2-elk-edge-spacing" help:"ELK engine: spacing to be preserved between nodes and edges that are routed next to the node’s layer" placeholder:"PIXELS"`
	SelfLoopSpacing *int64 `arg:"--d2-elk-self-loop-spacing" help:"ELK engine: spacing to be preserved between a node and its self loops" placeholder:"PIXELS"`
}

// DiagramCmdD2DagreOptions holds layout options specific to Dagre engine.
type DiagramCmdD2DagreOptions struct {
	NodeSep *int64 `arg:"--d2-dagre-node-sep" help:"Dagre engine: number of pixels that separate nodes" placeholder:"PIXELS"`
	EdgeSep *int64 `arg:"--d2-dagre-edge-sep" help:"Dagre engine: number of pixels that separate edges" placeholder:"PIXELS"`
}

func cliDiagram(cmd *DiagramCmd, globalConfig toolConfig) error {
	logger := log.GetLogger("")
	cmdConfig, err := cliDiagramMergeConfig(globalConfig, cmd)
	if err != nil {
		return fmt.Errorf("config: %w", err)
	}

	//
	// Compilation & linking
	//
	fileLocator := getLocator(cmdConfig)
	docURL, err := jsonpointer.Parse(cmd.Document)
	if err != nil {
		return fmt.Errorf("parse URL: %w", err)
	}
	compileOpts := compile.CompilationOpts{
		AllowRemoteRefs:     cmdConfig.Locator.AllowRemoteReferences,
		RuntimeModule:       cmdConfig.RuntimeModule,
		GeneratePublishers:  true,
		GenerateSubscribers: true,
	}
	documents, err := runCompilationAndLinking(fileLocator, docURL, compileOpts, protocolBuilders)
	if err != nil {
		return fmt.Errorf("compilation: %w", err)
	}

	//
	// Rendering
	//
	logger.Debug("Run objects rendering")
	renderManager := manager.NewTemplateRenderManager(common.RenderOpts{})
	templateDirs := []fs.FS{diagram.TemplateFS}
	if cmdConfig.Code.TemplatesDir != "" {
		logger.Debug("Custom templates location", "directory", cmdConfig.Code.TemplatesDir)
		templateDirs = append(templateDirs, os.DirFS(cmdConfig.Code.TemplatesDir))
	}
	tplLoader := tmpl.NewTemplateLoader(defaultMainTemplateName, templateDirs...)
	logger.Trace("Parse templates", "dirs", templateDirs)
	renderManager.TemplateLoader = tplLoader
	if err = tplLoader.ParseRecursive(renderManager); err != nil {
		return fmt.Errorf("parse templates: %w", err)
	}

	diagramConfig := getDiagramConfig(cmdConfig.Diagram)
	fileExtension := "." + strings.ToLower(string(cmdConfig.Diagram.Format))
	if cmdConfig.Diagram.MultipleFiles {
		artifactsByDoc := lo.MapValues(documents, func(d *compiler.Document, _ string) []common.Artifact {
			return lo.Filter(d.Artifacts(), func(a common.Artifact, _ int) bool {
				return a.Selectable() && a.Visible()
			})
		})
		logger.Debug("Render multiple diagram files", "count", len(artifactsByDoc))
		if err = renderer.RenderDiagramMultipleFiles(artifactsByDoc, fileExtension, diagramConfig, renderManager); err != nil {
			return fmt.Errorf("render diagrams: %w", err)
		}
	} else {
		allArtifacts := lo.Flatten(lo.Map(lo.Values(documents), func(d *compiler.Document, _ int) []common.Artifact {
			return d.Artifacts()
		}))
		artifacts := lo.Filter(allArtifacts, func(a common.Artifact, _ int) bool {
			return a.Selectable() && a.Visible()
		})
		logger.Debug("Render diagram file", "name", cmdConfig.Diagram.OutputFile, "objects", len(artifacts))
		fileName := cmdConfig.Diagram.OutputFile
		if fileName == "" {
			fileName = strings.TrimSuffix(path.Base(cmd.Document), path.Ext(cmd.Document)) + fileExtension
		}
		if err = renderer.RenderDiagramOneFile(artifacts, fileName, diagramConfig, renderManager); err != nil {
			return fmt.Errorf("render diagram: %w", err)
		}
	}

	//
	// Finishing d2 rendering
	//
	logger.Debug("Finish the files rendering")
	buffers, err := renderer.FinishFiles(renderManager)
	if err != nil {
		return fmt.Errorf("finish files: %w", err)
	}
	logger.Debug("Rendering finishing complete")

	//
	// Converting & formatting
	//
	needPostprocessing := cmdConfig.Diagram.Format != common.DiagramOutputFormatD2 || !cmdConfig.Diagram.DisableFormatting
	if needPostprocessing {
		logger.Debug("Run postprocessing", "files", len(buffers))
		if buffers, err = postprocessD2Files(buffers, cmdConfig); err != nil {
			return fmt.Errorf("postprocessing: %w", err)
		}
		logger.Debug("Postprocessing complete", "filesCount", len(buffers))
	}

	//
	// Writing
	//
	logger.Debug("Run writing")
	if err = writer.WriteBuffersToFiles(buffers, cmdConfig.Diagram.TargetDir); err != nil {
		return fmt.Errorf("writing: %w", err)
	}
	logger.Debug("Writing complete")
	return nil
}

func postprocessD2Files(buffers map[string]*bytes.Buffer, cmdConfig toolConfig) (map[string]*bytes.Buffer, error) {
	for fileName, srcBuf := range buffers {
		log.GetLogger("").Debug("Compiling d2 file", "file", fileName, "size", srcBuf.Len(), "opts", cmdConfig.Diagram.D2)
		diagramObj, graphObj, err := compileD2(srcBuf.Bytes(), cmdConfig.Diagram.D2)
		if err != nil {
			return nil, types.MultilineError{
				Err:     fmt.Errorf("compile d2: %w", err),
				Content: srcBuf.Bytes(),
			}
		}

		switch {
		case cmdConfig.Diagram.Format == common.DiagramOutputFormatSVG:
			log.GetLogger(log.LoggerPrefixRendering).Debug("-> Converting D2 diagram to SVG", "file", fileName)
			renderOpts, err := getD2RenderOpts(cmdConfig.Diagram.D2)
			if err != nil {
				return nil, fmt.Errorf("d2 render options: %w", err)
			}
			newBuf, err := d2svg.Render(diagramObj, &renderOpts)
			if err != nil {
				return nil, types.MultilineError{
					Err:     fmt.Errorf("render svg: %w", err),
					Content: srcBuf.Bytes(),
				}
			}
			buffers[fileName].Reset()
			buffers[fileName].Write(newBuf)

		case !cmdConfig.Diagram.DisableFormatting:
			log.GetLogger(log.LoggerPrefixFormatting).Debug("-> Formatting D2 file", "file", fileName)
			newBuf := []byte(d2format.Format(graphObj.BaseAST))
			buffers[fileName] = bytes.NewBuffer(newBuf)
		}
	}
	return buffers, nil
}

func cliDiagramMergeConfig(globalConfig toolConfig, cmd *DiagramCmd) (toolConfig, error) {
	res := globalConfig

	formats := []common.DiagramOutputFormat{
		common.DiagramOutputFormatD2, common.DiagramOutputFormatSVG,
	}
	res.Diagram.Format = coalesce(common.DiagramOutputFormat(cmd.Format), globalConfig.Diagram.Format)
	if !slices.Contains(formats, res.Diagram.Format) {
		return res, fmt.Errorf(
			"unknown diagram format %q, possible values: %s",
			cmd.Format,
			strings.Join(lo.Map(formats, func(f common.DiagramOutputFormat, _ int) string { return string(f) }), ", "),
		)
	}
	res.Diagram.OutputFile = coalesce(cmd.OutputFile, globalConfig.Diagram.OutputFile)
	res.Diagram.TargetDir = coalesce(cmd.TargetDir, globalConfig.Diagram.TargetDir)
	res.Diagram.MultipleFiles = coalesce(cmd.MultipleFiles, globalConfig.Diagram.MultipleFiles)
	res.Diagram.DisableFormatting = coalesce(cmd.DisableFormatting, globalConfig.Diagram.DisableFormatting)
	res.Diagram.ServersCentric = coalesce(cmd.ServersCentric, globalConfig.Diagram.ServersCentric)
	res.Diagram.ChannelsCentric = coalesce(cmd.ChannelsCentric, globalConfig.Diagram.ChannelsCentric)
	if res.Diagram.ChannelsCentric && res.Diagram.ServersCentric {
		return res, fmt.Errorf("diagram cannot be both channels-centric and servers-centric")
	}
	res.Diagram.DocumentBorders = coalesce(cmd.DocumentBorders, globalConfig.Diagram.DocumentBorders)

	engines := []d2DiagramEngine{D2DiagramEngineELK, D2DiagramEngineDagre}
	res.Diagram.D2.Engine = coalesce(d2DiagramEngine(cmd.Engine), globalConfig.Diagram.D2.Engine)
	if !slices.Contains(engines, res.Diagram.D2.Engine) {
		return res, fmt.Errorf(
			"unknown D2 diagram engine %q, possible values: %s",
			cmd.Engine,
			strings.Join(lo.Map(engines, func(e d2DiagramEngine, _ int) string { return string(e) }), ", "),
		)
	}
	directions := []common.D2DiagramDirection{
		common.D2DiagramDirectionUp, common.D2DiagramDirectionDown, common.D2DiagramDirectionLeft, common.D2DiagramDirectionRight,
	}
	res.Diagram.D2.Direction = coalesce(common.D2DiagramDirection(cmd.Direction), globalConfig.Diagram.D2.Direction)
	if !slices.Contains(directions, res.Diagram.D2.Direction) {
		return res, fmt.Errorf(
			"unknown D2 diagram direction %q, possible values: %s",
			res.Diagram.D2.Direction,
			strings.Join(lo.Map(directions, func(d common.D2DiagramDirection, _ int) string { return string(d) }), ", "),
		)
	}
	// General D2 options
	res.Diagram.D2.ThemeID = coalesce(cmd.ThemeID, globalConfig.Diagram.D2.ThemeID)
	res.Diagram.D2.DarkThemeID = coalesce(cmd.DarkThemeID, globalConfig.Diagram.D2.DarkThemeID)
	res.Diagram.D2.Pad = coalesce(cmd.Pad, globalConfig.Diagram.D2.Pad)
	res.Diagram.D2.Sketch = coalesce(cmd.Sketch, globalConfig.Diagram.D2.Sketch)
	res.Diagram.D2.Center = coalesce(cmd.Center, globalConfig.Diagram.D2.Center)
	res.Diagram.D2.Scale = coalesce(cmd.Scale, globalConfig.Diagram.D2.Scale)

	elkAlgorithms := []string{"layered", "force", "radial", "mrtree", "disco", "rectpacking"}
	res.Diagram.D2.ELK.Algorithm = coalesce(cmd.Algorithm, globalConfig.Diagram.D2.ELK.Algorithm)
	if !slices.Contains(elkAlgorithms, res.Diagram.D2.ELK.Algorithm) {
		return res, fmt.Errorf("unknown ELK algorithm %q, possible values: %s", res.Diagram.D2.ELK.Algorithm, strings.Join(elkAlgorithms, ", "))
	}
	res.Diagram.D2.ELK.NodeSpacing = *coalesce(cmd.NodeSpacing, &globalConfig.Diagram.D2.ELK.NodeSpacing)
	res.Diagram.D2.ELK.Padding = coalesce(cmd.Padding, globalConfig.Diagram.D2.ELK.Padding)
	res.Diagram.D2.ELK.EdgeSpacing = *coalesce(cmd.EdgeSpacing, &globalConfig.Diagram.D2.ELK.EdgeSpacing)
	res.Diagram.D2.ELK.SelfLoopSpacing = *coalesce(cmd.SelfLoopSpacing, &globalConfig.Diagram.D2.ELK.SelfLoopSpacing)

	res.Diagram.D2.Dagre.NodeSep = *coalesce(cmd.NodeSep, &globalConfig.Diagram.D2.Dagre.NodeSep)
	res.Diagram.D2.Dagre.EdgeSep = *coalesce(cmd.EdgeSep, &globalConfig.Diagram.D2.Dagre.EdgeSep)

	// Code generation

	res.Code.TemplatesDir = coalesce(cmd.TemplateDir, globalConfig.Code.TemplatesDir)

	res.Locator.AllowRemoteReferences = coalesce(cmd.AllowRemoteRefs, globalConfig.Locator.AllowRemoteReferences)
	res.Locator.SearchDirectory = coalesce(cmd.LocatorSearchDir, globalConfig.Locator.SearchDirectory)
	res.Locator.Timeout = coalesce(cmd.LocatorTimeout, globalConfig.Locator.Timeout)
	res.Locator.Command = coalesce(cmd.LocatorCommand, globalConfig.Locator.Command)

	return res, nil
}

func getDiagramConfig(conf toolConfigDiagram) common.ConfigDiagram {
	return common.ConfigDiagram{
		ShowChannels:        !conf.ServersCentric,
		ShowServers:         !conf.ChannelsCentric,
		ShowDocumentBorders: conf.DocumentBorders,
		D2DiagramDirection:  conf.D2.Direction,
	}
}

func compileD2(contents []byte, d2opts toolConfigDiagramD2Opts) (*d2target.Diagram, *d2graph.Graph, error) {
	engine := string(d2opts.Engine)

	ctx := d2log.With(context.Background(), slog.Default())
	ruler, err := textmeasure.NewRuler()
	if err != nil {
		return nil, nil, fmt.Errorf("create d2 text ruler: %w", err)
	}
	plugins, err := d2plugin.ListPlugins(ctx)
	if err != nil {
		return nil, nil, fmt.Errorf("list plugins: %w", err)
	}
	compileOpts := &d2lib.CompileOptions{
		Layout:         lo.ToPtr(engine),
		LayoutResolver: layoutResolver(ctx, plugins, d2opts),
		Ruler:          ruler,
	}
	renderOpts, err := getD2RenderOpts(d2opts)
	if err != nil {
		return nil, nil, fmt.Errorf("d2 render options: %w", err)
	}

	diagramObj, graphObj, err := d2lib.Compile(ctx, string(contents), compileOpts, &renderOpts)
	if err != nil {
		return nil, nil, fmt.Errorf("d2 compile: %w", err)
	}
	return diagramObj, graphObj, nil
}

func layoutResolver(ctx context.Context, plugins []d2plugin.Plugin, d2opts toolConfigDiagramD2Opts) func(engine string) (d2graph.LayoutGraph, error) {
	cached := make(map[string]d2graph.LayoutGraph)
	return func(engine string) (d2graph.LayoutGraph, error) {
		if c, ok := cached[engine]; ok {
			return c, nil
		}

		plugin, err := d2plugin.FindPlugin(ctx, plugins, engine)
		if err != nil {
			if errors.Is(err, exec.ErrNotFound) {
				return nil, fmt.Errorf("layout engine %q not found", engine)
			}
			return nil, err
		}

		var engineOpts []byte
		switch d2opts.Engine {
		case D2DiagramEngineELK:
			if engineOpts, err = d2opts.ELK.ToD2PluginOpts(); err != nil {
				return nil, fmt.Errorf("to %s options: %w", engine, err)
			}
		case D2DiagramEngineDagre:
			if engineOpts, err = d2opts.Dagre.ToD2PluginOpts(); err != nil {
				return nil, fmt.Errorf("to %s options: %w", engine, err)
			}
		default:
			return nil, fmt.Errorf("unknown D2 engine: %q", d2opts.Engine)
		}
		if err = plugin.HydrateOpts(engineOpts); err != nil {
			return nil, fmt.Errorf("hydrate %q engine options: %w", engine, err)
		}

		cached[engine] = plugin.Layout
		return plugin.Layout, nil
	}
}

func getD2RenderOpts(d2opts toolConfigDiagramD2Opts) (d2svg.RenderOpts, error) {
	if d2opts.DarkThemeID != nil {
		match := d2themescatalog.Find(*d2opts.DarkThemeID)
		if match == (d2themes.Theme{}) {
			return d2svg.RenderOpts{}, fmt.Errorf("dark theme not found. The available options are:\n%s", d2themescatalog.CLIString())
		}
	}
	if d2opts.ThemeID != nil {
		match := d2themescatalog.Find(*d2opts.ThemeID)
		if match == (d2themes.Theme{}) {
			return d2svg.RenderOpts{}, fmt.Errorf("theme not found. The available options are:\n%s", d2themescatalog.CLIString())
		}
	}
	return d2svg.RenderOpts{
		Pad:         d2opts.Pad,
		Sketch:      d2opts.Sketch,
		Center:      d2opts.Center,
		ThemeID:     coalesce(d2opts.ThemeID, d2opts.DarkThemeID),
		DarkThemeID: d2opts.DarkThemeID,
		Scale:       d2opts.Scale,
	}, nil
}
