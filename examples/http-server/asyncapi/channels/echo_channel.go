// Code generated by go-asyncapi tool. DO NOT EDIT.

package channels

import (
	"context"
	"errors"
	"fmt"
	"github.com/bdragon300/go-asyncapi/run"
	"github.com/bdragon300/go-asyncapi/run/http"
	http2 "http-server/asyncapi/impl/http"
	"http-server/asyncapi/messages"
)

func EchoChannelAddress() run.ParamString {
	return run.ParamString{
		Expr: "/echo",
	}
}

func NewEchoChannelHTTP(

	publisher http.Publisher,
	subscriber http.Subscriber,
) *EchoChannelHTTP {
	res := EchoChannelHTTP{
		address: EchoChannelAddress(), publisher: publisher, subscriber: subscriber,
	}
	return &res
}

func OpenEchoChannelHTTP(
	ctx context.Context,

	server EchoChannelServerHTTP,
) (*EchoChannelHTTP, error) {
	var err error
	address, err := EchoChannelAddress().Expand()
	if err != nil {
		return nil, err
	}
	var publisher http.Publisher
	producer := server.Producer()
	if producer != nil {
		publisher, err = producer.Publisher(ctx, address, nil, nil)
		if err != nil {
			return nil, err
		}
	}
	var subscriber http.Subscriber
	consumer := server.Consumer()
	if consumer != nil {
		subscriber, err = consumer.Subscriber(ctx, address, nil, nil)
		if err != nil {
			return nil, err
		}
	}

	return NewEchoChannelHTTP(

		publisher,
		subscriber,
	), nil
}

// EchoChannelHTTP--Channel for echoing messages.
type EchoChannelHTTP struct {
	address    run.ParamString
	publisher  http.Publisher
	subscriber http.Subscriber
}

func (c EchoChannelHTTP) Address() run.ParamString {
	return c.address
}

func (c EchoChannelHTTP) Close() (err error) {
	if c.publisher != nil {
		err = errors.Join(err, c.publisher.Close())
	}
	if c.subscriber != nil {
		err = errors.Join(err, c.subscriber.Close())
	}
	return
}

type EchoChannelEnvelopeMarshalerHTTP interface {
	MarshalEchoChannelHTTP(envelope http.EnvelopeWriter) error
}

func (c EchoChannelHTTP) SealServerRequest(
	envelope http.EnvelopeWriter,
	message EchoChannelEnvelopeMarshalerHTTP,
) error {
	if err := message.MarshalEchoChannelHTTP(envelope); err != nil {
		return err
	}

	return nil
}

func (c EchoChannelHTTP) PublishServerRequest(
	ctx context.Context,

	message EchoChannelEnvelopeMarshalerHTTP,
) error {
	envelope := http2.NewEnvelopeOut()
	if err := c.SealServerRequest(envelope, message); err != nil {
		return err
	}

	return c.Publish(ctx, envelope)
}
func (c EchoChannelHTTP) SealServerResponse(
	envelope http.EnvelopeWriter,
	message EchoChannelEnvelopeMarshalerHTTP,
) error {
	if err := message.MarshalEchoChannelHTTP(envelope); err != nil {
		return err
	}

	return nil
}

func (c EchoChannelHTTP) PublishServerResponse(
	ctx context.Context,

	message EchoChannelEnvelopeMarshalerHTTP,
) error {
	envelope := http2.NewEnvelopeOut()
	if err := c.SealServerResponse(envelope, message); err != nil {
		return err
	}

	return c.Publish(ctx, envelope)
}

func (c EchoChannelHTTP) Publisher() http.Publisher {
	return c.publisher
}

func (c EchoChannelHTTP) Publish(ctx context.Context, envelopes ...http.EnvelopeWriter) error {
	return c.publisher.Send(ctx, envelopes...)
}

type EchoChannelEnvelopeUnmarshalerHTTP interface {
	UnmarshalEchoChannelHTTP(envelope http.EnvelopeReader) error
}

func (c EchoChannelHTTP) UnsealServerRequest(
	envelope http.EnvelopeReader,
	message EchoChannelEnvelopeUnmarshalerHTTP,
) error {
	return message.UnmarshalEchoChannelHTTP(envelope)
}

func (c EchoChannelHTTP) SubscribeServerRequest(
	ctx context.Context,
	cb func(message messages.ServerRequestSender),
) (err error) {
	subCtx, cancel := context.WithCancelCause(ctx)
	defer cancel(nil)

	return c.Subscribe(subCtx, func(envelope http.EnvelopeReader) {
		message := new(messages.ServerRequestIn)
		if err2 := c.UnsealServerRequest(envelope, message); err2 != nil {
			err = fmt.Errorf("open message envelope: %w", err2)
			cancel(err)
			return
		}
		cb(message)
	})
}
func (c EchoChannelHTTP) UnsealServerResponse(
	envelope http.EnvelopeReader,
	message EchoChannelEnvelopeUnmarshalerHTTP,
) error {
	return message.UnmarshalEchoChannelHTTP(envelope)
}

func (c EchoChannelHTTP) SubscribeServerResponse(
	ctx context.Context,
	cb func(message messages.ServerResponseSender),
) (err error) {
	subCtx, cancel := context.WithCancelCause(ctx)
	defer cancel(nil)

	return c.Subscribe(subCtx, func(envelope http.EnvelopeReader) {
		message := new(messages.ServerResponseIn)
		if err2 := c.UnsealServerResponse(envelope, message); err2 != nil {
			err = fmt.Errorf("open message envelope: %w", err2)
			cancel(err)
			return
		}
		cb(message)
	})
}

func (c EchoChannelHTTP) Subscriber() http.Subscriber {
	return c.subscriber
}

func (c EchoChannelHTTP) Subscribe(ctx context.Context, cb func(envelope http.EnvelopeReader)) error {
	return c.subscriber.Receive(ctx, cb)
}

type EchoChannelServerHTTP interface {
	OpenEchoChannelHTTP(ctx context.Context) (*EchoChannelHTTP, error)
	Producer() http.Producer
	Consumer() http.Consumer
}
