// Code generated by go-asyncapi tool. DO NOT EDIT.

package channels

import (
	"context"
	"errors"
	"fmt"
	"github.com/bdragon300/go-asyncapi/run"
	"site-authorization/asyncapi/messages"
	"site-authorization/asyncapi/parameters"
	"site-authorization/asyncapi/proto/kafka"
)

type AuthChannelParameters struct {
	EnvironmentName parameters.EnvironmentName
}

func AuthChannelAddress(params AuthChannelParameters) run.ParamString {
	paramMap := map[string]string{
		"environmentName": string(params.EnvironmentName),
	}
	return run.ParamString{
		Expr:       "authChannel-{environmentName}",
		Parameters: paramMap,
	}
}

func NewAuthChannelKafka(
	params AuthChannelParameters,
	publisher kafka.Publisher,
	subscriber kafka.Subscriber,
) *AuthChannelKafka {
	res := AuthChannelKafka{
		address: AuthChannelAddress(params), publisher: publisher, subscriber: subscriber,
	}

	res.topic = res.address.String()
	return &res
}

type AuthChannelServerKafka interface {
	OpenAuthChannelKafka(context.Context, AuthChannelParameters, run.AnySecurityScheme) (*AuthChannelKafka, error)
	Producer() kafka.Producer
	Consumer() kafka.Consumer
}

func OpenAuthChannelKafka(
	ctx context.Context,
	server AuthChannelServerKafka,
	params AuthChannelParameters,
	opBindings *kafka.OperationBindings,
	security run.AnySecurityScheme,
) (*AuthChannelKafka, error) {
	var err error
	address, err := AuthChannelAddress(params).Expand()
	if err != nil {
		return nil, err
	}
	var publisher kafka.Publisher
	producer := server.Producer()
	if producer != nil {
		publisher, err = producer.Publisher(
			ctx,
			address,
			nil,
			opBindings,
			security,
		)
		if err != nil {
			return nil, err
		}
	}
	var subscriber kafka.Subscriber
	consumer := server.Consumer()
	if consumer != nil {
		subscriber, err = consumer.Subscriber(
			ctx,
			address,
			nil,
			opBindings,
			security,
		)
		if err != nil {
			return nil, err
		}
	}

	return NewAuthChannelKafka(
		params,
		publisher,
		subscriber,
	), nil
}

type AuthChannelKafka struct {
	address    run.ParamString
	publisher  kafka.Publisher
	subscriber kafka.Subscriber
	topic      string
}

func (c AuthChannelKafka) Topic() string {
	return c.topic
}

func (c AuthChannelKafka) Address() run.ParamString {
	return c.address
}

func (c AuthChannelKafka) Close() (err error) {
	if c.publisher != nil {
		err = errors.Join(err, c.publisher.Close())
	}
	if c.subscriber != nil {
		err = errors.Join(err, c.subscriber.Close())
	}
	return
}

type AuthChannelEnvelopeMarshalerKafka interface {
	MarshalAuthChannelKafka(envelope kafka.EnvelopeWriter) error
}

func (c AuthChannelKafka) SealAuthRequestMsg(
	envelope kafka.EnvelopeWriter,
	message AuthChannelEnvelopeMarshalerKafka,
) error {
	if err := message.MarshalAuthChannelKafka(envelope); err != nil {
		return err
	}

	envelope.SetTopic(c.Topic())
	return nil
}

func (c AuthChannelKafka) PublishAuthRequestMsg(
	ctx context.Context,

	message AuthChannelEnvelopeMarshalerKafka,
) error {
	envelope := kafka.NewEnvelopeOut(nil)
	if err := c.SealAuthRequestMsg(envelope, message); err != nil {
		return err
	}

	return c.Publish(ctx, envelope)
}
func (c AuthChannelKafka) SealAuthResponseMsg(
	envelope kafka.EnvelopeWriter,
	message AuthChannelEnvelopeMarshalerKafka,
) error {
	if err := message.MarshalAuthChannelKafka(envelope); err != nil {
		return err
	}

	envelope.SetTopic(c.Topic())
	return nil
}

func (c AuthChannelKafka) PublishAuthResponseMsg(
	ctx context.Context,

	message AuthChannelEnvelopeMarshalerKafka,
) error {
	envelope := kafka.NewEnvelopeOut(nil)
	if err := c.SealAuthResponseMsg(envelope, message); err != nil {
		return err
	}

	return c.Publish(ctx, envelope)
}

func (c AuthChannelKafka) Publisher() kafka.Publisher {
	return c.publisher
}

func (c AuthChannelKafka) Publish(ctx context.Context, envelopes ...kafka.EnvelopeWriter) error {
	return c.publisher.Send(ctx, envelopes...)
}

type AuthChannelEnvelopeUnmarshalerKafka interface {
	UnmarshalAuthChannelKafka(envelope kafka.EnvelopeReader) error
}

func (c AuthChannelKafka) UnsealAuthRequestMsg(
	envelope kafka.EnvelopeReader,
	message AuthChannelEnvelopeUnmarshalerKafka,
) error {
	return message.UnmarshalAuthChannelKafka(envelope)
}

func (c AuthChannelKafka) SubscribeAuthRequestMsg(
	ctx context.Context,
	cb func(message messages.AuthRequestMsgReceiver),
) (err error) {
	subCtx, cancel := context.WithCancel(ctx)
	defer cancel()

	subErr := c.Subscribe(subCtx, func(envelope kafka.EnvelopeReader) {
		message := new(messages.AuthRequestMsgIn)
		if err2 := c.UnsealAuthRequestMsg(envelope, message); err2 != nil {
			err = fmt.Errorf("%w: %w", run.ErrUnsealEnvelope, err2)
			cancel()
			return
		}
		cb(message)
	})
	if err != nil {
		return err
	}
	return subErr
}
func (c AuthChannelKafka) UnsealAuthResponseMsg(
	envelope kafka.EnvelopeReader,
	message AuthChannelEnvelopeUnmarshalerKafka,
) error {
	return message.UnmarshalAuthChannelKafka(envelope)
}

func (c AuthChannelKafka) SubscribeAuthResponseMsg(
	ctx context.Context,
	cb func(message messages.AuthResponseMsgReceiver),
) (err error) {
	subCtx, cancel := context.WithCancel(ctx)
	defer cancel()

	subErr := c.Subscribe(subCtx, func(envelope kafka.EnvelopeReader) {
		message := new(messages.AuthResponseMsgIn)
		if err2 := c.UnsealAuthResponseMsg(envelope, message); err2 != nil {
			err = fmt.Errorf("%w: %w", run.ErrUnsealEnvelope, err2)
			cancel()
			return
		}
		cb(message)
	})
	if err != nil {
		return err
	}
	return subErr
}

func (c AuthChannelKafka) Subscriber() kafka.Subscriber {
	return c.subscriber
}

func (c AuthChannelKafka) Subscribe(ctx context.Context, cb func(envelope kafka.EnvelopeReader)) error {
	return c.subscriber.Receive(ctx, cb)
}
