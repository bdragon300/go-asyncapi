// Code generated by go-asyncapi tool. DO NOT EDIT.

package kafka

import (
	"github.com/bdragon300/go-asyncapi/run"
)

import (
	"context"
	"fmt"

	"github.com/twmb/franz-go/pkg/kgo"
	"github.com/twmb/franz-go/pkg/kversion"
	"github.com/twmb/franz-go/pkg/sasl"
	"github.com/twmb/franz-go/pkg/sasl/plain"
)

func NewProducer(hosts []string, bindings *ServerBindings, security run.AnySecurityScheme, extraOpts ...kgo.Opt) *ProduceClient {
	return &ProduceClient{
		hosts:     hosts,
		bindings:  bindings,
		extraOpts: extraOpts,
		security:  security,
	}
}

type ProduceClient struct {
	hosts     []string
	bindings  *ServerBindings
	extraOpts []kgo.Opt
	security  run.AnySecurityScheme
}

func (p ProduceClient) Publisher(_ context.Context, address string, chb *ChannelBindings, opb *OperationBindings, security run.AnySecurityScheme) (Publisher, error) {
	// TODO: schema registry https://github.com/twmb/franz-go/blo6b/master/examples/schema_registry/schema_registry.go
	var opts []kgo.Opt

	opts = append(opts, kgo.SeedBrokers(p.hosts...))

	var saslMech []sasl.Mechanism
	for _, sec := range []run.AnySecurityScheme{p.security, security} {
		if sec == nil {
			continue
		}
		mech, err := toSaslMechanism(sec)
		if err != nil {
			return nil, err
		}
		saslMech = append(saslMech, mech)
	}
	if len(saslMech) > 0 {
		opts = append(opts, kgo.SASL(saslMech...))
	}

	topic := address
	if chb != nil && chb.Topic != "" {
		topic = chb.Topic
	}
	if topic != "" {
		opts = append(opts, kgo.DefaultProduceTopic(topic))
	}
	opts = append(opts, p.extraOpts...)

	cl, err := kgo.NewClient(opts...)
	if err != nil {
		return nil, err
	}

	return &PublishChannel{
		Client:            cl,
		Topic:             topic,
		channelBindings:   chb,
		operationBindings: opb,
	}, nil
}

type ImplementationRecord interface {
	AsFranzGoRecord() *kgo.Record
	// TODO: Bindings?
}

type PublishChannel struct {
	*kgo.Client
	Topic             string
	channelBindings   *ChannelBindings
	operationBindings *OperationBindings
}

func (p PublishChannel) Send(ctx context.Context, envelopes ...EnvelopeWriter) error {
	records := make([]*kgo.Record, 0, len(envelopes))
	for _, e := range envelopes {
		rm := e.(ImplementationRecord)
		records = append(records, rm.AsFranzGoRecord())
	}
	return p.Client.ProduceSync(ctx, records...).FirstErr()
}

func (p PublishChannel) Close() error {
	p.Client.Close()
	return nil
}

func toSaslMechanism(security run.AnySecurityScheme) (sasl.Mechanism, error) {
	switch v := security.(type) {
	case run.UserPasswordSecurity:
		u, p := v.UserPassword()
		return plain.Auth{User: u, Pass: p}.AsMechanism(), nil
	}
	return nil, fmt.Errorf("unsupported security scheme: %v", security.AuthType())
}

func ParseProtocolVersion(protocolVersion string) (*kversion.Versions, error) {
	var ver *kversion.Versions
	switch protocolVersion {
	case "stable":
		ver = kversion.Stable()
	case "tip":
		ver = kversion.Tip()
	case "0.8.0":
		ver = kversion.V0_8_0()
	case "0.8.1":
		ver = kversion.V0_8_1()
	case "0.8.2":
		ver = kversion.V0_8_2()
	case "0.9.0":
		ver = kversion.V0_9_0()
	case "0.10.0":
		ver = kversion.V0_10_0()
	case "0.10.1":
		ver = kversion.V0_10_1()
	case "0.10.2":
		ver = kversion.V0_10_2()
	case "0.11.0":
		ver = kversion.V0_11_0()
	case "1.0.0":
		ver = kversion.V1_0_0()
	case "1.1.0":
		ver = kversion.V1_1_0()
	case "2.0.0":
		ver = kversion.V2_0_0()
	case "2.1.0":
		ver = kversion.V2_1_0()
	case "2.2.0":
		ver = kversion.V2_2_0()
	case "2.3.0":
		ver = kversion.V2_3_0()
	case "2.4.0":
		ver = kversion.V2_4_0()
	case "2.5.0":
		ver = kversion.V2_5_0()
	case "2.6.0":
		ver = kversion.V2_6_0()
	case "2.7.0":
		ver = kversion.V2_7_0()
	case "2.8.0":
		ver = kversion.V2_8_0()
	case "3.0.0":
		ver = kversion.V3_0_0()
	case "3.1.0":
		ver = kversion.V3_1_0()
	case "3.2.0":
		ver = kversion.V3_2_0()
	case "3.3.0":
		ver = kversion.V3_3_0()
	case "3.4.0":
		ver = kversion.V3_4_0()
	case "3.5.0":
		ver = kversion.V3_5_0()
	default:
		return nil, fmt.Errorf("unknown protocol version: %s", protocolVersion)
	}

	return ver, nil
}
