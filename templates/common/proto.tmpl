{{define "channel/proto/commonMethods"}}
func (c {{.Type| gousage}}) Name() {{goqualrun "ParamString"}} {
    return c.name
}

func (c {{.Type| gousage}}) Close() (err error) {
    {{- if .IsPublisher}}
        if c.publisher != nil {
            err = {{goqual "errors.Join"}}(err, c.publisher.Close())
        }
    {{- end}}
    {{- if .IsSubscriber}}
        if c.subscriber != nil {
            err = {{goqual "errors.Join"}}(err, c.subscriber.Close())
        }
    {{- end}}
    return
}
{{- end}}

{{define "channel/proto/outputMethods"}}
func (c {{.Type| gousage}}) Publisher() {{goqualrun .Protocol "Publisher"}} {
    return c.publisher
}

func (c {{.Type| gousage}}) Publish(ctx {{goqual "context.Context"}}, envelopes ...{{goqualrun .Protocol "EnvelopeWriter"}}) error {
    return c.publisher.Send(ctx, envelopes...)
}
{{- end}}

{{- /* Common template for channel publish methods that doesn't contain protocol-specific bindings manipulations */}}
{{define "channel/proto/publishMethods"}}
{{template "channel/proto/outputMethods" .}}
func (c {{.Type| gousage}}) SealEnvelope(envelope {{goqualrun .Protocol "EnvelopeWriter"}}, message {{with visible .PublisherMessageType}}{{goptr .OutType}}{{else}}any{{end}}) error {
    envelope.ResetPayload()
    {{- if visible .PublisherMessageType}}
        {{- /*Message is set for Channel in spec*/}}
        if err := message.MarshalEnvelope{{.Protocol | capitalize | goid}}(envelope); err != nil {
            return err
        }
    {{- else}}
        {{- /* No Message set for Channel in spec */}}
        enc := {{goqual "encoding/json.NewEncoder"}}(envelope)
        if err := enc.Encode(message); err != nil {
            return err
        }
    {{- end}}
    {{- with trytmpl (print "channel/" .Protocol "/publishMethods/block1") .}}
        {{.}}
    {{- end}}
    {{- if and (visible .PublisherMessageType) (.PublisherMessageType.BindingsProtocols | has .Protocol)}}
        envelope.SetBindings({{.PublisherMessageType.BindingsType | gousage}}{}.{{.Protocol | capitalize | goid}}())
    {{- end}}
    return nil
}
{{- end}}

{{define "channel/proto/subscribeMethods"}}
func (c {{.Type| gousage}}) ExtractEnvelope(envelope {{goqualrun .Protocol "EnvelopeReader"}}, message {{with visible .SubscriberMessageType}}{{goptr .InType}}{{else}}any{{end}}) error {
    {{- if visible .SubscriberMessageType}}
        {{- /* Message set for Channel in spec */ -}}
        return message.UnmarshalEnvelope{{.Protocol | capitalize | goid}}(envelope)
    {{- else}}
        {{- /* No Message set for Channel in spec */ -}}
        dec := {{goqual "encoding/json.NewDecoder"}}(envelope)
        return dec.Decode(message)
    {{- end}}
}

func (c {{.Type| gousage}}) IsSubscriber() {{goqualrun .Protocol "Subscriber"}} {
    return c.subscriber
}

func (c {{.Type| gousage}}) Subscribe(ctx {{goqual "context.Context"}}, cb func(envelope {{goqualrun .Protocol "EnvelopeReader"}})) error {
    return c.subscriber.Receive(ctx, cb)
}
{{- end}}

{{- /* Common template for channel OpenChannel function that doesn't contain protocol-specific bindings manipulations */}}
{{define "channel/proto/openFunction"}}
func Open{{ .Channel | goid }}{{.Protocol | capitalize | goid}}(
    ctx {{goqual "context.Context"}},
    {{ if .ParametersType}}params {{.ParametersType | gousage}},{{end}}
    {{ if .IsPublisher}}producer {{goqualrun .Protocol "Producer"}},{{end}}
    {{ if .IsSubscriber}}consumer {{goqualrun .Protocol "Consumer"}},{{end}}
) (ch *{{.Type | gousage}}, err error) {
    name := {{.Channel | goid}}Name({{if .ParametersType}}params{{end}})
    {{- if .BindingsProtocols | has .Protocol}}
        bindings := {{.BindingsType | gousage}}{}.{{.Protocol | capitalize | goid}}()
    {{- end }}

    {{- if .IsPublisher}}
        var publisher {{goqualrun .Protocol "Publisher"}}
        if producer != nil {
            if publisher, err = producer.Publisher(ctx, name.String(), {{if .BindingsProtocols | has .Protocol}}&bindings{{else}}nil{{end}}); err != nil {
                return nil, err
            }
        }
    {{- end}}
    {{- if .IsSubscriber}}
        var subscriber {{goqualrun .Protocol "Subscriber"}}
        if consumer != nil {
            if subscriber, err = consumer.Subscriber(ctx, name.String(), {{if .BindingsProtocols | has .Protocol}}&bindings{{else}}nil{{end}}); err != nil {
                return nil, err
            }
        }
    {{- end}}

    return &{{.Type| gousage}}{
        name: name,
        {{ if .IsPublisher}}publisher: publisher,{{end}}
        {{ if .IsSubscriber}}subscriber: subscriber,{{end}}
    }, nil
}
{{- end}}

{{- /* Common template for channel NewChannel function that doesn't contain protocol-specific bindings manipulations */}}
{{define "channel/proto/newFunction"}}
func New{{ .Channel | goid }}{{.Protocol | capitalize | goid}}(
    {{- if .ParametersType}}params {{.ParametersType| gousage}},{{end}}
    {{- if .IsPublisher}}publisher {{goqualrun .Protocol "Publisher"}},{{end}}
    {{- if .IsSubscriber}}subscriber {{goqualrun .Protocol "Subscriber"}},{{end}}
) *{{.Type| gousage}} {
    res := {{.Type| gousage}}{
        name: {{.Channel | goid}}Name({{if .ParametersType}}params{{end}}),
        {{- if .IsPublisher}}publisher: publisher,{{end}}
        {{- if .IsSubscriber}}subscriber: subscriber,{{end}}
    }
    {{- with trytmpl (print "channel/" .Protocol "/newFunction/block1") .}}
        {{.}}
    {{- end}}
    return &res
}
{{- end}}

{{define "message/proto/marshalUnmarshalMethods"}}
func (m *{{ .OutType | goid }}) MarshalEnvelope{{ .Protocol | capitalize | goid }}(envelope {{goqualrun .Protocol "EnvelopeWriter"}}) error {
    {{- template "message/proto/encoder" .}}
    envelope.SetContentType({{.ContentType | golit}})
    {{- with .HeadersType}}
        envelope.SetHeaders({
        {{- range .Fields}}
            {{ .Name | golit}}: m.Headers.{{.Name}},
        {{- end}}
        })
    {{- else}}
        envelope.SetHeaders({{goqualrun "Headers"}}(m.Headers))
    {{- end}}
    return nil
}

func (m *{{ .InType | goid }}) UnmarshalEnvelope{{ .Protocol | capitalize | goid }}(envelope {{goqualrun .Protocol "EnvelopeReader"}}) error {
    {{- template "message/proto/decoder" .}}
    {{- with .HeadersType }}
        {{- /* Empty headers should not generate code */}}
        {{- if gt (len .Fields) 0}}
            headers := envelope.Headers()
            {{- range .Fields}}
                if v, ok := headers[{{.Name | golit}}]; ok {
                    m.Headers.{{.Name}} = v.({{.Type| gousage}})
                }
            {{- end}}
        {{- end}}
    {{- else}}
        m.Headers = {{.HeadersFallbackType| gousage}}(envelope.Headers())
    {{- end}}
    return nil
}
{{- end}}

{{define "message/proto/encoder"}}
{{with trytmpl (print "message/proto/encoder/" .EffectiveContentType) .}}
    {{.}}
{{else}}
    {{template "message/proto/encoder/default" .}}
{{end}}
{{- end}}

{{define "message/proto/decoder"}}
{{with trytmpl (print "message/proto/decoder/" .EffectiveContentType) .}}
    {{.}}
{{else}}
    {{template "message/proto/decoder/default" .}}
{{end}}
{{- end}}

{{define "server/proto/channelOpenMethods"}}
{{- range .GetBoundChannels}}
    {{- with deref .}}
        {{- with .SelectProtoObject $.Protocol }}
            func (s {{ $.Type | gousage }}) Open{{ .Type | goid }}(
                ctx {{goqual "context.Context"}},
                {{- if .ParametersType}}params {{ .ParametersType | gousage }},{{end}}
            ) (ch *{{ .Type | gousage }}, err error) {
                return {{gopkg .Type}}Open{{ .Type | goid }}(
                    ctx,
                    {{- if .ParametersType}}params,{{end}}
                    {{- if .IsPublisher}}s.producer,{{end}}
                    {{- if .IsSubscriber}}s.consumer,{{end}}
                )
            }
        {{- end}}
    {{- end}}
{{- end}}
{{- end}}
