{{define "proto/channel/commonMethods"}}
func (c {{.Struct.U}}) Name() {{qualr "" "ParamString"}} {
    return c.name
}

func (c {{.Struct.U}}) Close() (err error) {
    {{if .Publisher}}
        if c.publisher != nil {
            err = {{qual "errors.Join"}}(err, c.publisher.Close())
        }
    {{end}}
    {{if .Subscriber}}
        if c.subscriber != nil {
            err = {{qual "errors.Join"}}(err, c.subscriber.Close())
        }
    {{end}}
    return
}
{{end}}

{{define "proto/channel/outputMethods"}}
func (c {{.Struct.U}}) Publisher() {{qualr .ProtoName "Producer"}} {
    return c.publisher
}

func (c {{.Struct.U}}) Publish(ctx {{qual "context.Context"}}, envelopes ...{{qualr .ProtoName "EnvelopeWriter"}}) error {
    return c.publisher.Publish(ctx, envelopes...)
}
{{end}}

{{ /* Common template for channel publish methods that doesn't contain protocol-specific bindings manipulations */
define "proto/channel/barePublishMethods"}}
    {{template "proto/channel/outputMethods" .}}

    {{$pubMessageType := goptr .FallbackMessageType}}
    {{if .PubMessagePromise }}
        {{$pubMessageType = goptr .PubMessagePromise.T.OutStruct}}
    {{end}}

    func (c {{.Struct.U}}) SealEnvelope(envelope {{qualr .ProtoName "EnvelopeWriter"}}, message {{$pubMessageType.U}}) error {
        envelope.ResetPayload()
        {{if .PubMessagePromise /*Message is set for Channel in spec*/ }}
            if err := message.Marshal{{.ProtoName | title}}Envelope(envelope); err != nil {
                return err
            }
        {{else /*No Message set for Channel in spec*/}}
            enc := {{qual "encoding/json.NewEncoder"}}(envelope)
            if err := enc.Encode(message); err != nil {
                return err
            }
        {{end}}

        {{if and .PubMessagePromise (.PubMessagePromise.T.HasProtoBindings .ProtoName)}}
            envelope.SetBindings(.PubMessagePromise.T.BindingsStruct.U){}.{{.ProtoName | title}}()
        {{end}}
        return nil
    }
{{end}}

{{define "proto/channel/subscribeMethods"}}
{{$subMessageType := goptr .FallbackMessageType}}
{{if .PubMessagePromise }}
    {{$subMessageType = goptr .SubMessagePromise.T.InStruct}}
{{end}}
func (c {{.Struct.U}}) ExtractEnvelope(envelope {{qualr .ProtoName "EnvelopeReader"}}, message {{$subMessageType.U}}) error {
    {{if .SubMessagePromise}}
        {{/*Message set for Channel in spec*/}}
        return message.Unmarshal{{.ProtoName | title}}Envelope(envelope)
    {{else}}
        {{/*No Message set for Channel in spec*/}}
        dec := {{qual "encoding/json.NewDecoder"}}(envelope)
        return dec.Decode(message)
    {{end}}
}

func (c {{.Struct.U}}) Subscriber() {{qualr .ProtoName "Subscriber"}} {
    return c.subscriber
}

func (c {{.Struct.U}}) Subscribe(ctx {{qual "context.Context"}}, cb func(envelope {{qualr .ProtoName "EnvelopeReader"}})) error {
    return c.subscriber.Receive(ctx, cb)
}
{{end}}

{{ /* Common template for channel OpenChannel function that doesn't contain protocol-specific bindings manipulations */
define "proto/channel/openFunction"}}
    func Open{{.Struct.Name}}(
        ctx {{qual "context.Context"}},
        {{if .ParametersStruct}}params {{.ParametersStruct.U}},{{end}}
        {{if .Publisher}}producer {{qualr .ProtoName "Producer"}},{{end}}
        {{if .Subscriber}}consumer {{qualr .ProtoName "Consumer"}},{{end}}
    ) (ch *{{.Struct.U}}, err error) {
        name := {{.GolangName}}Name({{if .ParametersStruct}}params{{end}})
        bindings := {{.BindingsStruct.U}}{}.{{.ProtoName | title}}()

        {{if .Publisher}}
            var publisher {{qualr .ProtoName "Publisher"}}
            if producer != nil {
                if publisher, err = producer.Publisher(ctx, name, {{if .BindingsStruct}}&bindings{{else}}nil{{end}}); err != nil {
                    return nil, err
                }
            }
        {{end}}
        {{if .Subscriber}}
            var subscriber {{qualr .ProtoName "Subscriber"}}
            if consumer != nil {
                if subscriber, err = consumer.Consumer(ctx, name, {{if .BindingsStruct}}&bindings{{else}}nil{{end}}); err != nil {
                    return nil, err
                }
            }
        {{end}}

        return &{{.Struct.U}}{
            name: name,
            {{if .Publisher}}publisher: publisher,{{end}}
            {{if .Subscriber}}subscriber: subscriber,{{end}}
        }
    }
{{end}}

{{ /* Common template for channel NewChannel function that doesn't contain protocol-specific bindings manipulations */
define "proto/channel/bareNewFunction"}}
    func New{{.Struct.Name}}(
        {{if .ParametersStruct}}params {{.ParametersStruct.U}},{{end}}
        {{if .Publisher}}publisher {{qualr .ProtoName "Publisher"}},{{end}}
        {{if .Subscriber}}subscriber {{qualr .ProtoName "Subscriber"}},{{end}}
    ) *{{.Struct.U}} {
        res := {{.Struct.U}}{
            name: {{.GolangName}}Name({{if .ParametersStruct}}params{{end}}),
            {{if .Publisher}}publisher: publisher,{{end}}
            {{if .Subscriber}}subscriber: subscriber,{{end}}
        }
        return &res
    }
{{end}}

{{define "proto/message/marshalUnmarshalMethods"}}
func (m *{{.OutStruct.Name}}) Marshal{{ .ProtoName | title }}Envelope(envelope {{qualr .ProtoName "EnvelopeWriter"}} error {
    enc := {{qualg "encoding.NewEncoder"}}({{.ContentType | golit}}, envelope)
    if err := enc.Encode(m.Payload); err != nil {
        return err
    }
    envelope.SetContentType({{.ContentType | golit}})
    {{if .HeadersTypePromise}}
        envelope.SetHeaders({
        {{range $f := .HeadersTypePromise.T.Fields}}{{$f.Name | golit}}: m.Headers.{{$f.Name}},
        {{end}}
        })
    {{else}}
        envelope.SetHeaders({{qualr "" "Headers"}}(m.Headers))
    {{end}}
    return nil
}

func (m *{{.InStruct.Name}}) Unmarshal{{ .ProtoName | title }}Envelope(envelope {{qualr .ProtoName "EnvelopeReader"}} error {
    dec := {{qualg "encoding.NewDecoder"}}({{.ContentType | golit}}, envelope)
    if err := dec.Decode(&m.Payload); err != nil {
        return err
    }
    {{if .HeadersTypePromise }}
        {{/* Empty headers should not generate code */}}
        {{if gt (len .HeadersTypePromise.T.Fields) 0}}
            headers := envelope.Headers()
            {{range $f := .HeadersTypePromise.T.Fields}}
                if v, ok := headers[{{$f.Name | golit}}]; ok {
                    m.Headers.{{$f.Name}} = v.({{$f.Type.U}})
                }
            {{end}}
        {{end}}
    {{else}}
        m.Headers = {{.HeadersFallbackType.U}}(envelope.Headers())
    {{end}}
    return nil
}
{{end}}
