func readStreamWithContext(ctx {{goPkgExt "context"}}Context, input {{goPkgExt "io"}}Reader, payloadSeparator string) <-chan []byte {
	done := make(chan struct{})
	ch := make(chan []byte)
	buf := make([]byte, InputStreamBufferSize)
	go func() {
		select {
		case <-ctx.Done():
		case <-done:
		}
		close(ch)
	}()

	switch payloadSeparator {
	case "":
		{{goPkgExt "log/slog"}}Debug("Reading input as a single message")
		go func() {
			defer func() { done <- struct{}{} }()
			for {
				n, err := {{goPkgExt "io"}}ReadFull(input, buf)
				if err != nil && !{{goPkgExt "errors"}}Is(err, {{goPkgExt "io"}}ErrUnexpectedEOF) {
					{{goPkgExt "log/slog"}}Error("read stream: " + err.Error())
					break
				}
				ch <- buf[:n]
			}
		}()

	default:
		{{goPkgExt "log/slog"}}Debug("Splitting input by separator", "separator", payloadSeparator)
		scanner := {{goPkgExt "bufio"}}NewScanner(input)
		scanner.Buffer(buf, InputStreamBufferSize)
		scanner.Split(splitBySeparator(payloadSeparator))
		go func() {
			defer func() { done <- struct{}{} }()
			for scanner.Scan() {
				if scanner.Err() != nil {
					{{goPkgExt "log/slog"}}Error("read stream: " + scanner.Err().Error())
					break
				}
				ch <- scanner.Bytes()
			}
		}()
	}

	return ch
}

func splitBySeparator(separator string) {{goPkgExt "bufio"}}SplitFunc {
	return func(data []byte, atEOF bool) (advance int, token []byte, err error) {
		if atEOF && len(data) == 0 {
			return 0, nil, nil
		}
		if i := {{goPkgExt "strings"}}Index(string(data), separator); i >= 0 {
			return i + len(separator), data[0:i], nil
		}
		if atEOF {
			return len(data), data, nil
		}
		return 0, nil, nil
	}
}

func parseHeaders(headers map[string]string) {{goPkgRun}}Headers {
	h := make({{goPkgRun}}Headers, len(headers))
	for k, v := range headers {
		if uv, err := {{goPkgExt "strconv"}}ParseUint(v, 10, 64); err == nil {
			h[k] = uv
		} else if iv, err := {{goPkgExt "strconv"}}Atoi(v); err == nil {
			h[k] = iv
		} else if fv, err := {{goPkgExt "strconv"}}ParseFloat(v, 64); err == nil {
			h[k] = fv
		} else if bv, err := {{goPkgExt "strconv"}}ParseBool(v); err == nil {
			h[k] = bv
		} else {
			h[k] = v
		}
	}
	return h
}

func unescapeString(s string) string {
	var result []rune
	var escaped bool

	for _, r := range s {
		if escaped {
			switch r {
			case 'a':
				result = append(result, '\a')
			case 'b':
				result = append(result, '\b')
			case 'n':
				result = append(result, '\n')
			case 't':
				result = append(result, '\t')
			case 'r':
				result = append(result, '\r')
			case 'f':
				result = append(result, '\f')
			case 'v':
				result = append(result, '\v')
			case '\\':
				result = append(result, '\\')
			case '"':
				result = append(result, '"')
			case '\'':
				result = append(result, '\'')
			default:
				result = append(result, '\\', r)
			}
			escaped = false
		} else if r == '\\' {
			escaped = true
		} else {
			result = append(result, r)
		}
	}
	if escaped {
		result = append(result, '\\')
	}

	return string(result)
}

func showCliError(text string, cliParser *{{goPkgExt "github.com/alexflint/go-arg"}}Parser) {
	cliParser.Fail(text)
	{{goPkgExt "os"}}Exit(1)
}

func cutPayload(b []byte, maxSize int) string {
	if len(b) > maxSize {
		return {{goPkgExt "strings"}}ToValidUTF8(string(b[:maxSize]), "") + "..."
	} else {
		return {{goPkgExt "strings"}}ToValidUTF8(string(b), "")
	}
}