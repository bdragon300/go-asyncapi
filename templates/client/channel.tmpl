{{define "client/channel"}}
{{/* dot == render.Channel */}}
type {{$ | goIDUpper}}Cmd struct {
    // Parameters
    {{- range $k := .Parameters.Entries}}
	    {{$k | goIDUpper}} string `arg:"--{{$k | toQuotable | toKebabCase}},required" help:"Channel parameter: {{$k | toQuotable}}"`
    {{- end}}

	// Servers
    {{- range .BoundServers}}
        {{- if not (impl .Protocol)}}{{continue}}{{end}}
	    {{. | goIDUpper}}Cmd *{{. | goIDUpper}}CliCmd `arg:"subcommand:{{.Name | toQuotable | toKebabCase}}" help:"Server: {{.Name | toQuotable}}"`
    {{- end}}
}

func channel{{$ | goIDUpper}}(ctx {{goPkgExt "context"}}Context, args *{{$ | goIDUpper}}Cmd, opts channelOptions) error {
    {{- if .Parameters.Len}}
        channelParams := {{goPkg .}}{{goIDUpper .}}Parameters{
            {{- range $k, $v := .Parameters.Entries}}
                {{$k | goIDUpper}}: {{goPkg $v}}{{goIDUpper $v}}(args.{{$k | goIDUpper}}),
            {{- end}}
        }
	    {{goPkgExt "log/slog"}}Debug("Channel parameters", "value", channelParams)
    {{- end}}

	switch {
    {{- range .BoundServers}}
        {{- if not (impl .Protocol)}}{{continue}}{{end}}
        {{$implTemplateCtx := dict "Object" $ "Server" . "Kind" "channel"}}
        case args.{{. | goIDUpper}}Cmd != nil:
            {{template "client/pubsub/proto/serverPubSub" $implTemplateCtx}}
    {{- end}}
	default:
		showCliError("No server selected. Append --help for more information", opts.cliParser)
	}

	return nil
}
{{- end}}

{{define "client/operation"}}
{{/* dot == render.Operation */}}
type {{$ | goIDUpper}}Cmd struct {
    // Parameters
    {{- range $k := .Channel.Parameters.Entries}}
	    {{$k | goIDUpper}} string `arg:"--{{$k | toQuotable | toKebabCase}},required" help:"Channel parameter: {{$k | toQuotable}}"`
    {{- end}}

	// Servers
    {{- range .Channel.BoundServers}}
        {{- if not (impl .Protocol)}}{{continue}}{{end}}
	    {{. | goIDUpper}}Cmd *{{. | goIDUpper}}CliCmd `arg:"subcommand:{{.Name | toQuotable | toKebabCase}}" help:"Server: {{.Name | toQuotable}}"`
    {{- end}}
}

func operation{{$ | goIDUpper}}(ctx {{goPkgExt "context"}}Context, args *{{$ | goIDUpper}}Cmd, opts channelOptions) error {
    {{- if .Channel.Parameters.Len}}
        channelParams := {{goPkg .Channel}}{{goIDUpper .Channel}}Parameters{
            {{- range $k, $v := .Channel.Parameters.Entries}}
                {{$k | goIDUpper}}: {{goPkg $v}}{{goIDUpper $v}}(args.{{$k | goIDUpper}}),
            {{- end}}
        }
	    {{goPkgExt "log/slog"}}Debug("Channel parameters", "value", channelParams)
    {{- end}}

	switch {
    {{- range .Channel.BoundServers}}
        {{- if not (impl .Protocol)}}{{continue}}{{end}}
        {{$implTemplateCtx := dict "Object" $ "Server" . "Kind" "operation"}}
        case args.{{. | goIDUpper}}Cmd != nil:
            {{template "client/pubsub/proto/serverPubSub" $implTemplateCtx}}
    {{- end}}
	default:
		showCliError("No server selected. Append --help for more information", opts.cliParser)
	}

	return nil
}
{{- end}}

{{define "client/operationReply"}}
{{/* dot == render.Operation */}}
{{- $channel := .Channel }}
{{- if .OperationReply.Channel }}
    {{$channel = .OperationReply.Channel }}
{{- end}}
type {{$ | goIDUpper}}ReplyCmd struct {
    // Parameters
    {{- range $k := $channel.Parameters.Entries}}
	    {{$k | goIDUpper}} string `arg:"--{{$k | toQuotable | toKebabCase}},required" help:"Channel parameter: {{$k | toQuotable}}"`
    {{- end}}

	// Servers
    {{- range $channel.BoundServers}}
        {{- if not (impl .Protocol)}}{{continue}}{{end}}
	    {{. | goIDUpper}}Cmd *{{. | goIDUpper}}CliCmd `arg:"subcommand:{{.Name | toQuotable | toKebabCase}}" help:"Server: {{.Name | toQuotable}}"`
    {{- end}}
}

func operationReply{{$ | goIDUpper}}(ctx {{goPkgExt "context"}}Context, args *{{$ | goIDUpper}}ReplyCmd, opts channelOptions) error {
    {{- if $channel.Parameters.Len}}
        channelParams := {{goPkg $channel}}{{goIDUpper $channel}}Parameters{
            {{- range $k, $v := $channel.Parameters.Entries}}
                {{$k | goIDUpper}}: {{goPkg $v}}{{goIDUpper $v}}(args.{{$k | goIDUpper}}),
            {{- end}}
        }
	    {{goPkgExt "log/slog"}}Debug("Channel parameters", "value", channelParams)
    {{- end}}

	switch {
    {{- range $channel.BoundServers}}
        {{- if not (impl .Protocol)}}{{continue}}{{end}}
        {{$implTemplateCtx := dict "Object" $ "Server" . "Kind" "operationReply"}}
        case args.{{. | goIDUpper}}Cmd != nil:
            {{template "client/pubsub/proto/serverPubSub" $implTemplateCtx}}
    {{- end}}
	default:
		showCliError("No server selected. Append --help for more information", opts.cliParser)
	}

	return nil
}
{{- end}}

{{define "client/pubsub/proto/serverPubSub"}}
{{- /*
    .Object == render.Channel or render.Operation;
    .Server == render.Server
    .Kind == "channel" or "operation" or "operationReply"
    */}}
{{- $isPublisher := .Object.IsPublisher}}
{{- $isSubscriber := .Object.IsSubscriber}}

{{- if or (eq .Kind "operation") (eq .Kind "operationReply")}}
    {{- $isPublisher = .Object.HasPublishingCode}}
    {{- $isSubscriber = .Object.HasSubscribingCode}}
{{- end}}

{{- $impl := impl $.Server.Protocol}}
serverURL := args.{{$.Server | goIDUpper}}Cmd.URL
if serverURL == nil {
    u, err := {{goPkg $.Server}}{{goIDUpper $.Server}}URL(
        {{range $_, $v := $.Server.Variables.Entries}}args.{{goIDUpper $.Server}}Cmd.{{goIDUpper $v}},{{end}}
    )
    if err != nil {
        return {{goPkgExt "fmt"}}Errorf("url: %w", err)
    }
    serverURL = u
}
if opts.proxyHost != "" {
    if port := serverURL.Port(); port != "" {
        serverURL.Host = {{goPkgExt "net"}}JoinHostPort(opts.proxyHost, port)
    } else {
        serverURL.Host = opts.proxyHost
    }
}
{{goPkgExt "log/slog"}}Debug("Server URL", "value", serverURL)

{{goPkgExt "log/slog"}}Debug("Using implementation {{$impl.Name | toQuotable}}")
{{- with tryTmpl (print "client/channeloperation/" $.Server.Protocol "/" $impl.Name "/setup") $}}
    // Implementation-specific code
    {{.}}
    // End of implementation-specific code
{{- end}}

{{goPkgExt "log/slog"}}Debug("Connecting to server", "name", {{$.Server.Name | goLit}}, "url", serverURL)
if opts.publish {
    {{- if and $.Server.IsPublisher $isPublisher}}
        {{- with tryTmpl (print "client/channeloperation/" $.Server.Protocol "/" $impl.Name "/producer/connect") $}}
            // Implementation-specific code
            {{.}}
            // End of implementation-specific code
        {{- else}}
            server, err := {{goPkg $.Server}}Connect{{$.Server | goIDUpper}}Producer(ctx, serverURL)
            if err != nil {
                return {{goPkgExt "fmt"}}Errorf("connect server %s: %w", serverURL, err)
            }
            defer server.Close()
        {{end}}

        {{template "client/pubsub/proto/serverPubSub/open" $}}

        {{goPkgExt "log/slog"}}Debug("Reading data to publish to {{$.Kind}}...")
        // If separator is empty, then don't use scanner and just read everything until EOF
        for b := range readStreamWithContext(ctx, opts.stream, opts.payloadSeparator) {
            envelope := {{goPkgImpl $.Server.Protocol}}NewEnvelopeOut(nil)
            n, err := envelope.Write(b)
            if err != nil {
                return {{goPkgExt "fmt"}}Errorf("write envelope: %w", err)
            }
            {{goPkgExt "log/slog"}}Debug("Read message payload", "bytes", n)
            parsedHeaders := parseHeaders(opts.publishHeaders)
            envelope.SetHeaders(parsedHeaders)
            {{ with tryTmpl (print "client/" $.Kind "/" $.Server.Protocol "/publish/prepareEnvelope") $.Object}}
                // Protocol-specific code
                {{.}}
                // End of protocol-specific code
            {{end}}

            {{- with tryTmpl (print "client/message/" $.Server.Protocol "/" $impl.Name "/publish") $}}
                // Implementation-specific code
                {{.}}
                // End of implementation-specific code
            {{- end}}

            if opts.debug {
                {{goPkgExt "log/slog"}}Debug("Publishing message", "bytes", n, "payload", cutPayload(b, MaxLogPayloadSize), "headers", parsedHeaders)
            }
            if err := channel.Publish(ctx, envelope); err != nil {
                return {{goPkgExt "fmt"}}Errorf("publish: %w", err)
            }
            if !opts.multipleMessages {
                break
            }
        }
        _ = channel
    {{- else}}
        return {{goPkgExt "fmt"}}Errorf("publishing for {{$.Kind}} {{$.Server.Name | toQuotable}} is not supported in specification or disabled")
    {{- end}}
} else {
    {{- if and $.Server.IsSubscriber $isSubscriber}}
        {{- with tryTmpl (print "client/channeloperation/" $.Server.Protocol "/" $impl.Name "/consumer/connect") $}}
            // Implementation-specific code
            {{.}}
            // End of implementation-specific code
        {{- else}}
            server, err := {{goPkg $.Server}}Connect{{goIDUpper $.Server}}Consumer(ctx, serverURL)
            if err != nil {
                return {{goPkgExt "fmt"}}Errorf("connect server %s: %w", serverURL, err)
            }
            defer server.Close()
        {{- end}}
        {{template "client/pubsub/proto/serverPubSub/open" $}}

        {{goPkgExt "log/slog"}}Debug("Subscribing to {{$.Kind}}...", "separator", opts.payloadSeparator)
        subCtx, cancel := {{goPkgExt "context"}}WithCancelCause(ctx)
        defer cancel(ErrExited)
        payloadSeparator := []byte(opts.payloadSeparator)
        err = channel.Subscribe(subCtx, func(e {{goPkgUtil $.Server.Protocol}}EnvelopeReader) {
            b, err := {{goPkgExt "io"}}ReadAll(e)
            if err != nil {
                cancel({{goPkgExt "fmt"}}Errorf("read: %w", err))
                return
            }
            if opts.debug {
                var p string
                if len(b) > MaxLogPayloadSize {
                    p = {{goPkgExt "strings"}}ToValidUTF8(string(b[:MaxLogPayloadSize]), "") + "..."
                } else {
                    p = {{goPkgExt "strings"}}ToValidUTF8(string(b), "")
                }
                {{goPkgExt "log/slog"}}Debug("Received message", "bytes", len(b), "payload", p, "headers", e.Headers())
            }
            if _, err = opts.stream.Write(b); err != nil {
                cancel({{goPkgExt "fmt"}}Errorf("write to stream: %w", err))
                return
            }
            if _, err = opts.stream.Write(payloadSeparator); err != nil {
                cancel({{goPkgExt "fmt"}}Errorf("write payload separator to stream: %w", err))
                return
            }
            if !opts.multipleMessages {
                cancel(ErrExited)
            }
        })
        ctxCause := {{goPkgExt "context"}}Cause(subCtx)
        switch {
        case {{goPkgExt "errors"}}Is(ctxCause, ErrExited):
            return nil
        case ctxCause != nil:
            return {{goPkgExt "fmt"}}Errorf("message processing: %w", ctxCause)
        case err != nil:
            return {{goPkgExt "fmt"}}Errorf("subscribe: %w", err)
        }
        _ = channel
    {{- else}}
        return {{goPkgExt "fmt"}}Errorf("subscribing for {{$.Kind}} {{$.Server.Name | toQuotable}} is not supported in specification or disabled")
    {{- end}}
}
{{- end}}

{{define "client/pubsub/proto/serverPubSub/open"}}
{{- with $.Object}}
    {{- if eq $.Kind "channel"}}
        {{goPkgExt "log/slog"}}Debug("Opening channel", "name", {{.Name | goLit}}{{if .Parameters.Len}}, "parameters", channelParams{{end}})
        object, err := server.Open{{goIDUpper .}}{{goIDUpper $.Server.Protocol}}(
            ctx,
            {{if .Parameters.Len}}channelParams,{{end}}
        )
        channel := object
    {{- else if eq $.Kind "operation" }}
        {{goPkgExt "log/slog"}}Debug("Opening operation", "name", {{.Name | goLit}}{{if .Channel.Parameters.Len}}, "parameters", channelParams{{end}})
        object, err := server.Open{{goIDUpper .}}{{goIDUpper $.Server.Protocol}}(
            ctx,
            {{if .Channel.Parameters.Len}}channelParams,{{end}}
        )
        channel := object.Channel.({{goPkg .Channel}}{{goIDUpper .Channel}}{{goIDUpper $.Server.Protocol}})
    {{- else if eq $.Kind "operationReply" }}
        {{- with $channel := .BoundOperationReplyChannel }}
            {{goPkgExt "log/slog"}}Debug("Opening operation reply", "name", {{.Name | goLit}}{{if $channel.Parameters.Len}}, "parameters", channelParams{{end}})
            object, err := server.Open{{goIDUpper $channel}}{{goIDUpper $.Server.Protocol}}(
                ctx,
                {{if $channel.Parameters.Len}}channelParams,{{end}}
            )
            channel := object
        {{- end}}
    {{- end}}
    if err != nil {
        return {{goPkgExt "fmt"}}Errorf("open {{.Kind}}: %w", err)
    }
{{- end}}
defer object.Close()
{{- end}}