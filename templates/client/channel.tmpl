{{define "client/channel"}}
{{/* dot == render.Channel */}}
type {{$ | goIDUpper}}Cmd struct {
    // Parameters
    {{- range .Parameters.Entries}}
	    {{.Key | goIDUpper}} string `arg:"--{{.Key | toQuotable | toKebabCase}},required" help:"Channel parameter: {{.Key | toQuotable}}"`
    {{- end}}

	// Servers
    {{- range .BoundServers}}
	    {{. | goIDUpper}}Cmd *{{. | goIDUpper}}CliCmd `arg:"subcommand:{{.Name | toQuotable | toKebabCase}}" help:"Server: {{.Name | toQuotable}}"`
    {{- end}}
}

func channel{{$ | goIDUpper}}(ctx {{"context.Context"}}, args *{{$ | goIDUpper}}Cmd, opts channelOptions) error {
    {{- if .ParametersType}}
        channelParams := {{goUsage .ParametersType}}{
            {{- range .Parameters.Entries}}
                {{.Key | goIDUpper}}: {{goUsage .Value.Type}}(args.{{.Key | goIDUpper}}),
            {{- end}}
        }
	    {{goQual "log/slog.Debug"}}("Channel parameters", "value", channelParams)
    {{- end}}

	switch {
    {{- range .BoundServers}}
        {{$implTemplateCtx := dict "Object" $ "Server" . "Kind" "channel"}}
        case args.{{. | goIDUpper}}Cmd != nil:
            {{template "client/pubsub/proto/serverPubSub" $implTemplateCtx}}
    {{- end}}
	default:
		showCliError("No server selected. Append --help for more information", opts.cliParser)
	}

	return nil
}
{{- end}}

{{define "client/operation"}}
{{/* dot == render.Operation */}}
type {{$ | goIDUpper}}Cmd struct {
    // Parameters
    {{- range .Channel.Parameters.Entries}}
	    {{.Key | goIDUpper}} string `arg:"--{{.Key | toQuotable | toKebabCase}},required" help:"Channel parameter: {{.Key | toQuotable}}"`
    {{- end}}

	// Servers
    {{- range .Channel.BoundServers}}
	    {{. | goIDUpper}}Cmd *{{. | goIDUpper}}CliCmd `arg:"subcommand:{{.Name | toQuotable | toKebabCase}}" help:"Server: {{.Name | toQuotable}}"`
    {{- end}}
}

func operation{{$ | goIDUpper}}(ctx {{"context.Context"}}, args *{{$ | goIDUpper}}Cmd, opts channelOptions) error {
    {{- if .Channel.ParametersType}}
        channelParams := {{goUsage .Channel.ParametersType}}{
            {{- range .Channel.Parameters.Entries}}
                {{.Key | goIDUpper}}: {{goUsage .Value.Type}}(args.{{.Key | goIDUpper}}),
            {{- end}}
        }
	    {{goQual "log/slog.Debug"}}("Channel parameters", "value", channelParams)
    {{- end}}

	switch {
    {{- range .Channel.BoundServers}}
        {{$implTemplateCtx := dict "Object" $ "Server" . "Kind" "operation"}}
        case args.{{. | goIDUpper}}Cmd != nil:
            {{template "client/pubsub/proto/serverPubSub" $implTemplateCtx}}
    {{- end}}
	default:
		showCliError("No server selected. Append --help for more information", opts.cliParser)
	}

	return nil
}
{{- end}}

{{define "client/operationReply"}}
{{/* dot == render.Operation */}}
{{- $channel := .Channel }}
{{- if .OperationReply.Channel }}
    {{$channel = .OperationReply.Channel }}
{{- end}}
type {{$ | goIDUpper}}ReplyCmd struct {
    // Parameters
    {{- range $channel.Parameters.Entries}}
	    {{.Key | goIDUpper}} string `arg:"--{{.Key | toQuotable | toKebabCase}},required" help:"Channel parameter: {{.Key | toQuotable}}"`
    {{- end}}

	// Servers
    {{- range $channel.BoundServers}}
	    {{. | goIDUpper}}Cmd *{{. | goIDUpper}}CliCmd `arg:"subcommand:{{.Name | toQuotable | toKebabCase}}" help:"Server: {{.Name | toQuotable}}"`
    {{- end}}
}

func operationReply{{$ | goIDUpper}}(ctx {{"context.Context"}}, args *{{$ | goIDUpper}}ReplyCmd, opts channelOptions) error {
    {{- if $channel.ParametersType}}
        channelParams := {{goUsage $channel.ParametersType}}{
            {{- range $channel.Parameters.Entries}}
                {{.Key | goIDUpper}}: {{goUsage .Value.Type}}(args.{{.Key | goIDUpper}}),
            {{- end}}
        }
	    {{goQual "log/slog.Debug"}}("Channel parameters", "value", channelParams)
    {{- end}}

	switch {
    {{- range $channel.BoundServers}}
        {{$implTemplateCtx := dict "Object" $ "Server" . "Kind" "operationReply"}}
        case args.{{. | goIDUpper}}Cmd != nil:
            {{template "client/pubsub/proto/serverPubSub" $implTemplateCtx}}
    {{- end}}
	default:
		showCliError("No server selected. Append --help for more information", opts.cliParser)
	}

	return nil
}
{{- end}}

{{define "client/pubsub/proto/serverPubSub"}}
{{- /*
    .Object == render.Channel or render.Operation;
    .Server == render.Server
    .Kind == "channel" or "operation" or "operationReply"
    */}}

{{- $channel := .Object}}
{{- $isPublisher := .Object.IsPublisher}}
{{- $isSubscriber := .Object.IsSubscriber}}

{{- if eq .Kind "operation"}}
    {{- $channel = .Object.Channel}}
    {{- $isPublisher = .Object.HasPublishingCode}}
    {{- $isSubscriber = .Object.HasSubscribingCode}}
{{- else if eq .Kind "operationReply"}}
    {{- $channel = .Object.Channel}}
    {{- if .Object.OperationReply.Channel}}
        {{- $channel = .Object.OperationReply.Channel}}
    {{- end}}
    {{- $isPublisher = .Object.HasPublishingCode}}
    {{- $isSubscriber = .Object.HasSubscribingCode}}
{{- end}}

{{- with .Server}}
serverURL := args.{{$.Server | goIDUpper}}Cmd.URL
if serverURL == nil {
    u, err := {{goPkg .}}{{. | goIDUpper}}URL(
        {{range .Variables.Entries}}args.{{$.Server | goIDUpper}}Cmd.{{.Value | goIDUpper}},{{end}}
    )
    if err != nil {
        return {{goQual "fmt.Errorf"}}("url: %w", err)
    }
    serverURL = u
}
if opts.proxyHost != "" {
    if port := serverURL.Port(); port != "" {
        serverURL.Host = {{goQual "net.JoinHostPort"}}(opts.proxyHost, port)
    } else {
        serverURL.Host = opts.proxyHost
    }
}
{{goQual "log/slog.Debug"}}("Server URL", "value", serverURL)

{{- with impl .Protocol}}
    {{goQual "log/slog.Debug"}}("Using implementation {{.Manifest.Name | toQuotable}}")
    {{- with tryTmpl (print "client/channeloperation/" $.Server.Protocol "/" .Manifest.Name "/setup") $}}
        // Implementation-specific code
        {{.}}
        // End of implementation-specific code
    {{- end}}
{{end}}

{{goQual "log/slog.Debug"}}("Connecting to server", "name", {{$.Server.Name | goLit}}, "url", serverURL)
if opts.publish {
    {{- if and .IsPublisher $isPublisher}}
        {{- with impl .Protocol}}
            {{- with tryTmpl (print "client/channeloperation/" $.Server.Protocol "/" .Manifest.Name "/producer/connect") $}}
                // Implementation-specific code
                {{.}}
                // End of implementation-specific code
            {{- else}}
                server, err := {{goPkg $.Server}}Connect{{$.Server | goIDUpper}}Producer(ctx, serverURL)
                if err != nil {
                    return {{goQual "fmt.Errorf"}}("connect server %s: %w", serverURL, err)
                }
                defer server.Close()
            {{- end}}
        {{end}}

        {{goQual "log/slog.Debug"}}("Opening channel", "name", {{.Name | goLit}}{{with $channel.ParametersType}}, "parameters", channelParams{{end}})
        channel, err := server.Open{{$channel | goIDUpper}}{{.Protocol | goIDUpper}}(ctx{{with $channel.ParametersType}}, channelParams{{end}})
        if err != nil {
            return {{goQual "fmt.Errorf"}}("open channel: %w", err)
        }
        defer channel.Close()

        {{goQual "log/slog.Debug"}}("Reading data to publish to {{$.Kind}}...")
        // If separator is empty, then don't use scanner and just read everything until EOF
        for b := range readStreamWithContext(ctx, opts.stream, opts.payloadSeparator) {
            {{with impl .Protocol}}envelope := {{goPkg .}}NewEnvelopeOut(){{end}}
            n, err := envelope.Write(b)
            if err != nil {
                return {{goQual "fmt.Errorf"}}("write envelope: %w", err)
            }
            {{goQual "log/slog.Debug"}}("Read message payload", "bytes", n)
            parsedHeaders := parseHeaders(opts.publishHeaders)
            envelope.SetHeaders(parsedHeaders)
            {{ with tryTmpl (print "client/" $.Kind "/" .Protocol "/publish/prepareEnvelope") $.Object}}
                // Protocol-specific code
                {{.}}
                // End of protocol-specific code
            {{end}}

            {{- with impl .Protocol}}
                {{- with tryTmpl (print "client/message/" $.Server.Protocol "/" .Manifest.Name "/publish") $}}
                    // Implementation-specific code
                    {{.}}
                    // End of implementation-specific code
                {{- end}}
            {{end}}

            if opts.debug {
                {{goQual "log/slog.Debug"}}("Publishing message", "bytes", n, "payload", cutPayload(b, MaxLogPayloadSize), "headers", parsedHeaders)
            }
            if err := channel.Publish(ctx, envelope); err != nil {
                return {{goQual "fmt.Errorf"}}("publish: %w", err)
            }
            if !opts.multipleMessages {
                break
            }
        }
    {{- else}}
        return {{goQual "fmt.Errorf"}}("publishing for {{$.Kind}} {{.Name | toQuotable}} is not supported in specification or disabled")
    {{- end}}
} else {
    {{- if and .IsSubscriber $isSubscriber}}
        {{- with impl .Protocol}}
            {{- with tryTmpl (print "client/channeloperation/" $.Server.Protocol "/" .Manifest.Name "/consumer/connect") $}}
                // Implementation-specific code
                {{.}}
                // End of implementation-specific code
            {{- else}}
                server, err := {{goPkg $.Server}}Connect{{$.Server | goIDUpper}}Consumer(ctx, serverURL)
                if err != nil {
                    return {{goQual "fmt.Errorf"}}("connect server %s: %w", serverURL, err)
                }
                defer server.Close()
            {{- end}}
        {{end}}

        {{goQual "log/slog.Debug"}}("Opening channel", "name", {{.Name | goLit}}{{with $channel.ParametersType}}, "parameters", channelParams{{end}})
        channel, err := server.Open{{$channel | goIDUpper}}{{.Protocol | goIDUpper}}(ctx{{with $channel.ParametersType}}, channelParams{{end}})
        if err != nil {
            return {{goQual "fmt.Errorf"}}("open channel: %w", err)
        }
        defer channel.Close()

        {{goQual "log/slog.Debug"}}("Subscribing to {{$.Kind}}...", "separator", opts.payloadSeparator)
        subCtx, cancel := {{goQual "context.WithCancelCause"}}(ctx)
        defer cancel(ErrExited)
        payloadSeparator := []byte(opts.payloadSeparator)
        err = channel.Subscribe(subCtx, func(e {{goQualR .Protocol "EnvelopeReader"}}) {
            b, err := {{goQual "io.ReadAll"}}(e)
            if err != nil {
                cancel({{goQual "fmt.Errorf"}}("read: %w", err))
                return
            }
            if opts.debug {
                var p string
                if len(b) > MaxLogPayloadSize {
                    p = {{goQual "strings.ToValidUTF8"}}(string(b[:MaxLogPayloadSize]), "") + "..."
                } else {
                    p = {{goQual "strings.ToValidUTF8"}}(string(b), "")
                }
                {{goQual "log/slog.Debug"}}("Received message", "bytes", len(b), "payload", p, "headers", e.Headers())
            }
            if _, err = opts.stream.Write(b); err != nil {
                cancel({{goQual "fmt.Errorf"}}("write stream: %w", err))
                return
            }
            if _, err = opts.stream.Write(payloadSeparator); err != nil {
                cancel({{goQual "fmt.Errorf"}}("write stream: %w", err))
                return
            }
            if !opts.multipleMessages {
                cancel(ErrExited)
            }
        })
        ctxCause := {{goQual "context.Cause"}}(subCtx)
        switch {
        case {{goQual "errors.Is"}}(ctxCause, ErrExited):
            return nil
        case ctxCause != nil:
            return {{goQual "fmt.Errorf"}}("message processing: %w", ctxCause)
        case err != nil:
            return {{goQual "fmt.Errorf"}}("subscribe: %w", err)
        }
    {{- else}}
        return {{goQual "fmt.Errorf"}}("subscribing for {{$.Kind}} {{.Name | toQuotable}} is not supported in specification or disabled")
    {{- end}}
}
{{- end}}

{{- end}}