{{- /* dot == render.ProtoOperation */}}

{{block "code/proto/operation/serverInterface" .}}
    type {{ . | goID }}Server{{.Protocol | goID}} interface {
        Open{{.Channel | goID}}{{.Protocol | goID}}({{goPkgExt "context"}}Context{{if .Channel.Parameters.Len}},{{goPkg .Channel}}{{goID .Channel}}Parameters{{end}}{{if .Channel.BoundOperations}},{{goPkgRun}}AnySecurityScheme{{end}}) (*{{goPkg .Channel}}{{goID .Channel}}{{goID .Protocol}}, error)
        Open{{. | goID}}{{.Protocol | goID}}({{goPkgExt "context"}}Context{{if .Channel.Parameters.Len}}, {{goPkg .Channel}}{{goID .Channel}}Parameters{{end}}{{if .SecuritySchemes}}, {{. | goID}}Security,{{end}}) (*{{. | goID}}{{.Protocol | goID}}, error)
        {{if .Channel.IsPublisher}}Producer() {{goPkgUtil .Protocol}}Producer{{end}}
        {{if .Channel.IsSubscriber}}Consumer() {{goPkgUtil .Protocol}}Consumer{{end}}
    }
{{- end}}


{{if .SecuritySchemes}}{{block "code/proto/operation/securityInterface" .}}
type {{. | goID}}Security interface {
    {{goPkgRun}}AnySecurityScheme
    {{. | goID }}Security()
}
{{- end}}{{- end}}


{{block "code/proto/operation/openFunction" .}}
func Open{{ . | goID }}{{.Protocol | goID}}(
    ctx {{goPkgExt "context"}}Context,
    server {{. | goID }}Server{{.Protocol | goID}},
    {{ if .Channel.Parameters.Len}}params {{goPkg .Channel}}{{goID .Channel}}Parameters,{{end}}
    {{if .SecuritySchemes}}security {{. | goID}}Security,{{end}}
) (*{{. | goID}}{{.Protocol | goID}}, error) {
    {{- if .BindingsProtocols | has .Protocol}}
        opBindings := {{goPkg .Operation}}{{goID .Operation}}Bindings{}.{{.Protocol | goID}}()
    {{- end }}
    ch, err := {{goPkg .Channel}}Open{{.Channel | goID}}{{.Protocol | goID}}(
        ctx,
        server,
        {{if .Channel.Parameters.Len}}params,{{end}}
        {{if .BindingsProtocols | has .Protocol}}&opBindings{{else}}nil{{end}},
        {{if .SecuritySchemes}}security{{else}}nil{{end}},
    )
    if err != nil {
        return nil, err
    }

    return &{{. | goID}}{{.Protocol | goID}}{
        Channel: ch,
    }, nil
}
{{- end}}

type {{ . | goID }}Channel{{.Protocol | goID}} interface {
    Close() error
    {{range .BoundMessages}}
        {{- if not (isVisible .) }}{{continue}}{{end}}
        {{if .IsPublisher}}
            Seal{{goID .}}({{goPkgUtil $.Protocol}}EnvelopeWriter, {{goPkg $.Channel}}{{ goID $.Channel }}EnvelopeMarshaler{{$.Protocol | goID}}) error
            Publish{{goID .}}({{goPkgExt "context"}}Context, {{if not (impl $.Protocol)}}{{goPkgUtil $.Protocol}}EnvelopeWriter,{{end}} {{goPkg $.Channel}}{{ goID $.Channel }}EnvelopeMarshaler{{$.Protocol | goID}}) error
        {{- end}}
        {{if .IsSubscriber}}
            Unseal{{goID .}}({{goPkgUtil $.Protocol}}EnvelopeReader, {{goPkg $.Channel}}{{ goID $.Channel }}EnvelopeUnmarshaler{{$.Protocol | goID}}) error
            Subscribe{{goID .}}({{goPkgExt "context"}}Context, func({{ goPkg .InType}}{{ goID .}}Receiver)) error
        {{- end}}
    {{- end}}
}

type {{. | goID}}{{.Protocol | goID}} struct {
    Channel {{ . | goID }}Channel{{.Protocol | goID}}
}


{{block "code/proto/operation/commonMethods" .}}
func (c {{. | goID}}{{.Protocol | goID}}) Close() error {
    return c.Channel.Close()
}

{{- if .BindingsProtocols | has .Protocol}}
func (c {{. | goID}}{{.Protocol | goID}}) Bindings() {{goPkgUtil .Protocol}}OperationBindings {
    return {{goPkg .Operation}}{{goID .Operation}}Bindings{}.{{.Protocol | goID}}()
}
{{- end}}

{{if or .IsReplyPublisher .IsReplySubscriber}}
    func (c {{. | goID}}{{.Protocol | goID}}) Reply({{if .OperationReply.Channel}}channel {{ . | goID }}ReplyChannel{{.Protocol | goID}}{{end}}) *{{goPkg .}}{{. | goID}}{{.Protocol | goID}}Reply {
        return &{{. | goID}}{{.Protocol | goID}}Reply{Channel: {{with .OperationReply.Channel}}channel{{else}}c.Channel{{end}} }
    }
{{- end}}
{{- end}}


{{- if .IsPublisher}}{{block "code/proto/operation/publishMethods" .}}
{{- range .BoundMessages}}
    {{- if not (isVisible .) }}{{continue}}{{end}}
    func (o {{$ | goID}}{{$.Protocol | goID}}) Seal{{. | goID}}(
        envelope {{goPkgUtil $.Protocol}}EnvelopeWriter,
        message {{goPkg $.Channel}}{{ goID $.Channel }}EnvelopeMarshaler{{$.Protocol | goID}},
    ) error {
        return o.Channel.Seal{{. | goID}}(envelope, message)
    }

    func (o {{$ | goID}}{{$.Protocol | goID}}) Publish{{. | goID}}(
        ctx {{goPkgExt "context"}}Context,
        {{if not (impl $.Protocol)}}envelope {{goPkgUtil $.Protocol}}EnvelopeWriter,{{end}}
        message {{goPkg $.Channel}}{{ goID $.Channel }}EnvelopeMarshaler{{$.Protocol | goID}},
    ) error {
        return o.Channel.Publish{{. | goID}}(ctx, {{if not (impl $.Protocol)}}envelope,{{end}} message)
    }
{{- end}}
{{- end}}{{- end}}


{{- if .IsSubscriber}}{{block "code/proto/operation/subscribeMethods" .}}
{{- range .BoundMessages}}
    {{- if not (isVisible .) }}{{continue}}{{end}}
    func (o {{$ | goID}}{{$.Protocol | goID}}) Unseal{{. | goID}}(
        envelope {{goPkgUtil $.Protocol}}EnvelopeReader,
        message {{goPkg $.Channel}}{{ goID $.Channel }}EnvelopeUnmarshaler{{$.Protocol | goID}},
    ) error {
        return o.Channel.Unseal{{. | goID}}(envelope, message)
    }

    func (o {{$ | goID}}{{$.Protocol | goID}}) Subscribe{{. | goID}}(
        ctx {{goPkgExt "context"}}Context,
        cb func(message {{ goPkg .InType}}{{ goID .}}Receiver),
    ) (err error) {
        return o.Channel.Subscribe{{. | goID}}(ctx, cb)
    }
{{- end}}
{{- end}}{{- end}}


{{- if or .IsReplyPublisher .IsReplySubscriber}}
    {{- $replyCh := $.OperationReply.Channel }}
    {{- $innerChannel := .ProtoChannel.Channel}}
    {{- if .OperationReply.Channel}}{{$innerChannel = .OperationReply.Channel}}{{end}}

    type {{ . | goID }}ReplyChannel{{.Protocol | goID}} interface {
        Close() error
        {{range .BoundReplyMessages}}
            {{- if not (isVisible .) }}{{continue}}{{end}}
            {{if $.IsReplyPublisher}}
                Seal{{goID .}}({{goPkgUtil $.Protocol}}EnvelopeWriter, {{goPkg $replyCh}}{{ goID $replyCh }}EnvelopeMarshaler{{$.Protocol | goID}}) error
                Publish{{goID .}}({{goPkgExt "context"}}Context, {{if not (impl $.Protocol)}}{{goPkgUtil $.Protocol}}EnvelopeWriter,{{end}} {{goPkg $replyCh}}{{ goID $replyCh }}EnvelopeMarshaler{{$.Protocol | goID}}) error
            {{- end}}
            {{if $.IsReplySubscriber}}
                Unseal{{goID .}}({{goPkgUtil $.Protocol}}EnvelopeReader, {{goPkg $replyCh}}{{ goID $replyCh }}EnvelopeUnmarshaler{{$.Protocol | goID}}) error
                Subscribe{{goID .}}({{goPkgExt "context"}}Context, func({{ goPkg .InType}}{{ goID .}}Receiver)) error
            {{- end}}
        {{- end}}
    }

    type {{$ | goID}}{{$.Protocol | goID}}Reply struct {
        Channel {{ . | goID }}ReplyChannel{{.Protocol | goID}}
    }

    {{- if .IsReplyPublisher}}{{block "code/proto/operation/operationReply/publishMethods" .}}
        {{- range .BoundReplyMessages }}
            {{- $replyCh := $.OperationReply.Channel }}
            {{- if not (isVisible .) }}{{continue}}{{end}}
            func (o {{$ | goID}}{{$.Protocol | goID}}Reply) Seal{{. | goID}}(
                envelope {{goPkgUtil $.Protocol}}EnvelopeWriter,
                message {{goPkg $replyCh}}{{ goID $replyCh }}EnvelopeMarshaler{{$.Protocol | goID}},
            ) error {
                return o.Channel.Seal{{. | goID}}(envelope, message)
            }

            func (o {{$ | goID}}{{$.Protocol | goID}}Reply) Reply{{. | goID}}(
                ctx {{goPkgExt "context"}}Context,
                {{if not (impl $.Protocol)}}envelope {{goPkgUtil $.Protocol}}EnvelopeWriter,{{end}}
                {{if $.OperationReply.OperationReplyAddress}}
                    {{- $ctx := dict "SourceVarName" "o" "RuntimeExpression" $.OperationReply.OperationReplyAddress.BaseRuntimeExpression "TargetType" .OutType}}
                    message interface{ {{goPkg $replyCh}}{{ goID $replyCh }}EnvelopeMarshaler{{$.Protocol | goID}}; SetReplyAddress{{ $ | goID }}(a {{template "code/runtimeExpression/varType" $ctx}}) },
                    replyAddress {{template "code/runtimeExpression/varType" $ctx}},
                {{- else }}
                    message {{goPkg $replyCh}}{{ goID $replyCh }}EnvelopeMarshaler{{$.Protocol | goID}},
                {{- end}}
            ) error {
                {{- if $.OperationReply.OperationReplyAddress}}
                    message.SetReplyAddress{{$ | goID}}(replyAddress)
                {{- end}}
                return o.Channel.Publish{{. | goID}}(ctx, {{if not (impl $.Protocol)}}envelope, {{end}}message)
            }
        {{- end}}
    {{- end}}{{end}}

    {{- if .IsReplySubscriber}}{{block "code/proto/operation/operationReply/subscribeMethods" .}}
        {{- range .BoundReplyMessages }}
            {{- if not (isVisible .) }}{{continue}}{{end}}
            func (o {{$ | goID}}{{$.Protocol | goID}}Reply) Unseal{{. | goID}}(
                envelope {{goPkgUtil $.Protocol}}EnvelopeReader,
                message {{goPkg $.Channel}}{{ goID $.Channel }}EnvelopeUnmarshaler{{$.Protocol | goID}},
            ) error {
                return o.Channel.Unseal{{. | goID}}(envelope, message)
            }

            func (o {{$ | goID}}{{$.Protocol | goID}}Reply) Subscribe{{. | goID}}(
                ctx {{goPkgExt "context"}}Context,
                cb func(message {{ goPkg .InType}}{{ goID .}}Receiver),
            ) (err error) {
                return o.Channel.Subscribe{{. | goID}}(ctx, cb)
            }
        {{- end}}
    {{- end}}{{end}}

    {{block "code/proto/operation/operationReply/commonMethods" .}}
    {{- end}}
{{- end}}
