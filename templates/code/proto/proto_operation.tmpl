{{- /* dot == render.ProtoOperation */}}

{{define "code/proto/operation/channelInterface"}}
type {{ . | goIDUpper }}Channel{{.Protocol | goIDUpper}} interface {
    {{- if .IsPublisher}}
        Publish(ctx {{goQual "context.Context"}}, envelopes ...{{goQualR $.Protocol "EnvelopeWriter"}}) error
    {{- end}}
    {{- if .IsSubscriber}}
        Subscribe(ctx {{goQual "context.Context"}}, handler func(envelope {{goQualR $.Protocol "EnvelopeReader"}})) error
    {{- end}}
    Operation{{. | goIDUpper}}() *{{. | goIDUpper}}{{.Protocol | goIDUpper}}
    {{- if and (or .IsReplyPublisher .IsReplySubscriber) (not .OperationReply.Channel)}}
        {{- /* Both Operation and OperationReply bounds with the same channel*/}}
        {{- if .IsReplyPublisher}}
            Publish(ctx {{goQual "context.Context"}}, envelopes ...{{goQualR $.Protocol "EnvelopeWriter"}}) error
        {{- end}}
        {{- if .IsReplySubscriber}}
            Subscribe(ctx {{goQual "context.Context"}}, handler func(envelope {{goQualR $.Protocol "EnvelopeReader"}})) error
        {{- end}}
        Reply{{. | goIDUpper}}() *{{. | goIDUpper}}{{.Protocol | goIDUpper}}Reply
    {{- end}}
}
{{- end}}

{{define "code/proto/operation/commonMethods"}}
{{- if .BindingsProtocols | has .Protocol}}
func (c {{. | goIDUpper}}{{.Protocol | goIDUpper}}) Bindings() {{goQualR .Protocol "OperationBindings"}} {
    return {{.BindingsType | goUsage}}{}.{{.Protocol | goIDUpper}}()
}
{{- end}}

{{if or .IsReplyPublisher .IsReplySubscriber}}
    func (c {{. | goIDUpper}}{{.Protocol | goIDUpper}}) Reply({{if .OperationReply.Channel}}channel {{ . | goIDUpper }}ReplyChannel{{.Protocol | goIDUpper}}{{end}}) *{{goPkg .}}{{. | goIDUpper}}{{.Protocol | goIDUpper}}Reply {
        return &{{. | goIDUpper}}{{.Protocol | goIDUpper}}Reply{Channel: {{with .OperationReply.Channel}}channel{{else}}c.Channel{{end}} }
    }
{{- end}}
{{- end}}

{{define "code/proto/operation/publishMethods"}}
type {{ . | goIDUpper }}EnvelopeMarshaler{{.Protocol | goIDUpper}} interface {
    Marshal{{. | goIDUpper}}{{.Protocol | goIDUpper}}(envelope {{goQualR .Protocol "EnvelopeWriter"}}) error
}

{{- range .BoundMessages}}
    {{- if not (isVisible .) }}{{continue}}{{end}}
    func (o {{$ | goIDUpper}}{{$.Protocol | goIDUpper}}) Seal{{. | goIDUpper}}(
        envelope {{goQualR $.Protocol "EnvelopeWriter"}},
        message {{ $ | goIDUpper }}EnvelopeMarshaler{{$.Protocol | goIDUpper}},
    ) error {
        if err := message.Marshal{{$ | goIDUpper}}{{$.Protocol | goIDUpper}}(envelope); err != nil {
            return err
        }
        {{ with tryTmpl (print "code/proto/" $.Protocol "/operation/publishMethods/block1") .}}{{.}}{{end}}
        {{- if .BindingsProtocols | has $.Protocol }}
            envelope.SetBindings({{.BindingsType | goUsage}}{}.{{$.Protocol | goIDUpper}}())
        {{- end}}
        return nil
    }

    func (o {{$ | goIDUpper}}{{$.Protocol | goIDUpper}}) Publish{{. | goIDUpper}}(
        ctx {{goQual "context.Context"}},
        {{if not (impl $.Protocol)}}envelope {{goQualR $.Protocol "EnvelopeWriter"}},{{end}}
        message {{ $ | goIDUpper }}EnvelopeMarshaler{{$.Protocol | goIDUpper}},
    ) error {
        {{- with impl $.Protocol}}
            envelope := {{goPkg .}}NewEnvelopeOut()
        {{- end}}
        if err := o.Seal{{. | goIDUpper}}(envelope, message); err != nil {
            return err
        }
        {{ with tryTmpl (print "code/proto/" $.Protocol "/operation/publishMethods/block2") .}}{{.}}{{end}}
        return o.Channel.Publish(ctx, envelope)
    }
{{- end}}
{{- end}}


{{define "code/proto/operation/subscribeMethods"}}
type {{ . | goIDUpper }}EnvelopeUnmarshaler{{.Protocol | goIDUpper}} interface {
    Unmarshal{{. | goIDUpper}}{{.Protocol | goIDUpper}}(envelope {{goQualR .Protocol "EnvelopeReader"}}) error
}

{{- range .BoundMessages}}
    {{- if not (isVisible .) }}{{continue}}{{end}}
    func (o {{$ | goIDUpper}}{{$.Protocol | goIDUpper}}) Unseal{{. | goIDUpper}}(
        envelope {{goQualR $.Protocol "EnvelopeReader"}},
        message {{ $ | goIDUpper }}EnvelopeUnmarshaler{{$.Protocol | goIDUpper}},
    ) error {
        return message.Unmarshal{{$ | goIDUpper}}{{$.Protocol | goIDUpper}}(envelope)
    }

    func (o {{$ | goIDUpper}}{{$.Protocol | goIDUpper}}) Subscribe{{. | goIDUpper}}(
        ctx {{goQual "context.Context"}},
        cb func(message {{ goPkg .InType}}{{ goIDUpper .}}Receiver),
    ) (err error) {
        subCtx, cancel := {{goQual "context.WithCancelCause"}}(ctx)
        defer cancel(nil)

        return o.Channel.Subscribe(subCtx, func(envelope {{goQualR $.Protocol "EnvelopeReader"}}) {
            message := new({{ .InType | goUsage }})
            if err2 := o.Unseal{{. | goIDUpper}}(envelope, message); err2 != nil {
                err = {{goQual "fmt.Errorf"}}("open message envelope: %w", err2)
                cancel(err)
                return
            }
            cb(message)
        })
    }
{{- end}}
{{- end}}

{{define "code/proto/operation/operationReply/channelInterface"}}
type {{ . | goIDUpper }}ReplyChannel{{.Protocol | goIDUpper}} interface {
    {{- if .IsReplyPublisher}}
        Publish(ctx {{goQual "context.Context"}}, envelopes ...{{goQualR $.Protocol "EnvelopeWriter"}}) error
    {{- end}}
    {{- if .IsReplySubscriber}}
        Subscribe(ctx {{goQual "context.Context"}}, handler func(envelope {{goQualR $.Protocol "EnvelopeReader"}})) error
    {{- end}}
    Reply{{. | goIDUpper}}() *{{. | goIDUpper}}{{.Protocol | goIDUpper}}Reply
}
{{- end}}

{{define "code/proto/operation/operationReply/commonMethods"}}
{{- end}}

{{define "code/proto/operation/operationReply/publishMethods"}}
type {{ . | goIDUpper }}EnvelopeMarshaler{{.Protocol | goIDUpper}} interface {
    Marshal{{. | goIDUpper}}{{.Protocol | goIDUpper}}(envelope {{goQualR .Protocol "EnvelopeWriter"}}) error
}

{{- range .BoundReplyMessages }}
    {{- if not (isVisible .) }}{{continue}}{{end}}
    func (o {{$ | goIDUpper}}{{$.Protocol | goIDUpper}}Reply) Seal{{. | goIDUpper}}(
        envelope {{goQualR $.Protocol "EnvelopeWriter"}},
        message {{ $ | goIDUpper }}EnvelopeMarshaler{{$.Protocol | goIDUpper}},
    ) error {
        if err := message.Marshal{{$ | goIDUpper}}{{$.Protocol | goIDUpper}}(envelope); err != nil {
            return err
        }
        {{ with tryTmpl (print "code/proto/" $.Protocol "/operation/publishMethods/block1") .}}{{.}}{{end}}
        {{- if .BindingsProtocols | has $.Protocol }}
            envelope.SetBindings({{.BindingsType | goUsage}}{}.{{$.Protocol | goIDUpper}}())
        {{- end}}
        return nil
    }

    func (o {{$ | goIDUpper}}{{$.Protocol | goIDUpper}}Reply) Reply{{. | goIDUpper}}(
        ctx {{goQual "context.Context"}},
        {{if not (impl $.Protocol)}}envelope {{goQualR $.Protocol "EnvelopeWriter"}},{{end}}
        {{if $.OperationReply.OperationReplyAddress}}
            {{- $ctx := dict "SourceVarName" "o" "RuntimeExpression" $.OperationReply.OperationReplyAddress.BaseRuntimeExpression "TargetType" .OutType}}
            message interface{ {{ $ | goIDUpper }}EnvelopeMarshaler{{$.Protocol | goIDUpper}}; SetReplyAddress{{ $ | goIDUpper }}(a {{template "code/runtimeExpression/varType" $ctx}}) },
            replyAddress {{template "code/runtimeExpression/varType" $ctx}},
        {{- else }}
            message {{ $ | goIDUpper }}EnvelopeMarshaler{{$.Protocol | goIDUpper}},
        {{- end}}
    ) error {
        {{- with impl $.Protocol}}
            envelope := {{goPkg .}}NewEnvelopeOut()
        {{- end}}
        {{- if $.OperationReply.OperationReplyAddress}}
            message.SetReplyAddress{{$ | goIDUpper}}(replyAddress)
        {{- end}}
        if err := o.Seal{{. | goIDUpper}}(envelope, message); err != nil {
            return err
        }
        {{ with tryTmpl (print "code/proto/" $.Protocol "/operation/publishMethods/block2") .}}{{.}}{{end}}
        return o.Channel.Publish(ctx, envelope)
    }
{{- end}}
{{- end}}

{{define "code/proto/operation/operationReply/subscribeMethods"}}
type {{ . | goIDUpper }}EnvelopeUnmarshaler{{.Protocol | goIDUpper}} interface {
    Unmarshal{{. | goIDUpper}}{{.Protocol | goIDUpper}}(envelope {{goQualR .Protocol "EnvelopeReader"}}) error
}

{{- range .BoundReplyMessages }}
    {{- if not (isVisible .) }}{{continue}}{{end}}
    func (o {{$ | goIDUpper}}{{$.Protocol | goIDUpper}}Reply) Unseal{{. | goIDUpper}}(
        envelope {{goQualR $.Protocol "EnvelopeReader"}},
        message {{ $ | goIDUpper }}EnvelopeUnmarshaler{{$.Protocol | goIDUpper}},
    ) error {
        return message.Unmarshal{{$ | goIDUpper}}{{$.Protocol | goIDUpper}}(envelope)
    }

    func (o {{$ | goIDUpper}}{{$.Protocol | goIDUpper}}Reply) Subscribe{{. | goIDUpper}}(
        ctx {{goQual "context.Context"}},
        cb func(message {{ goPkg .InType}}{{ goIDUpper .}}Receiver),
    ) (err error) {
        subCtx, cancel := {{goQual "context.WithCancelCause"}}(ctx)
        defer cancel(nil)

        return o.Channel.Subscribe(subCtx, func(envelope {{goQualR $.Protocol "EnvelopeReader"}}) {
            message := new({{ .InType | goUsage }})
            if err2 := o.Unseal{{. | goIDUpper}}(envelope, message); err2 != nil {
                err = {{goQual "fmt.Errorf"}}("open message envelope: %w", err2)
                cancel(err)
                return
            }
            cb(message)
        })
    }
{{- end}}
{{- end}}

