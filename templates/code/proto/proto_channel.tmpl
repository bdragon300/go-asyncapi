{{- /* dot == render.ProtoChannel */}}

{{block "code/proto/channel/newFunction" .}}
func New{{ .Channel | goID }}{{.Protocol | goID}}(
    {{ if .Parameters.Len}}params {{ goID .Channel}}Parameters,{{end}}
    {{ if .IsPublisher}}publisher {{goPkgUtil .Protocol}}Publisher,{{end}}
    {{ if .IsSubscriber}}subscriber {{goPkgUtil .Protocol}}Subscriber,{{end}}
) *{{. | goID}}{{.Protocol | goID}} {
    res := {{. | goID}}{{.Protocol | goID}}{
        address: {{.Channel | goID}}Address({{if .Parameters.Len}}params{{end}}),
        {{- if .IsPublisher}}publisher: publisher,{{end}}
        {{- if .IsSubscriber}}subscriber: subscriber,{{end}}
    }
    {{- with tryTmpl (print "code/proto/" .Protocol "/channel/newFunction/block1") .}}
        {{.}}
    {{- end}}
    return &res
}
{{- end}}


{{block "code/proto/channel/serverInterface" .}}
type {{ .Channel | goID }}Server{{.Protocol | goID}} interface {
    Open{{.Channel | goID}}{{.Protocol | goID}}({{goPkgExt "context"}}Context{{if .Parameters.Len}},{{goID .Channel}}Parameters{{end}}{{if .BoundOperations}},{{goPkgRun}}AnySecurityScheme{{end}}) (*{{. | goID}}{{.Protocol | goID}}, error)
    {{if .IsPublisher}}Producer() {{goPkgUtil .Protocol}}Producer{{end}}
    {{if .IsSubscriber}}Consumer() {{goPkgUtil .Protocol}}Consumer{{end}}
}
{{- end}}


{{block "code/proto/channel/openFunction" .}}
func Open{{ .Channel | goID }}{{.Protocol | goID}}(
    ctx {{goPkgExt "context"}}Context,
    server {{.Channel | goID }}Server{{.Protocol | goID}},
    {{if .Parameters.Len}}params {{goID .}}Parameters,{{end}}
    {{if .BoundOperations}}opBindings *{{goPkgUtil .Protocol}}OperationBindings,{{end}}
    {{if .BoundOperations}}security {{goPkgRun}}AnySecurityScheme,{{end}}
) (*{{. | goID}}{{.Protocol | goID}}, error) {
    var err error
    {{- if .BindingsProtocols | has .Protocol}}
        chBindings := {{goPkg .Channel}}{{goID .Channel}}Bindings{}.{{.Protocol | goID}}()
    {{- end }}

    {{- if or .IsPublisher .IsSubscriber}}
        address, err := {{.Channel | goID}}Address({{if .Parameters.Len}}params{{end}}).Expand()
        if err != nil {
            return nil, err
        }
    {{- end}}
    {{- if .IsPublisher}}
        var publisher {{goPkgUtil .Protocol}}Publisher
        producer := server.Producer()
        if producer != nil {
            publisher, err = producer.Publisher(
                ctx,
                address,
                {{if .BindingsProtocols | has .Protocol}}&chBindings{{else}}nil{{end}},
                {{if .BoundOperations}}opBindings{{else}}nil{{end}},
                {{if .BoundOperations}}security{{else}}nil{{end}},
            )
            if err != nil {
                return nil, err
            }
        }
    {{- end}}
    {{- if .IsSubscriber}}
        var subscriber {{goPkgUtil .Protocol}}Subscriber
        consumer := server.Consumer()
        if consumer != nil {
            subscriber, err = consumer.Subscriber(
                ctx,
                address,
                {{if .BindingsProtocols | has .Protocol}}&chBindings{{else}}nil{{end}},
                {{if .BoundOperations}}opBindings{{else}}nil{{end}},
                {{if .BoundOperations}}security{{else}}nil{{end}},
            )
            if err != nil {
                return nil, err
            }
        }
    {{- end}}

    return New{{ .Channel | goID }}{{.Protocol | goID}}(
        {{ if .Parameters.Len}}params,{{end}}
        {{ if .IsPublisher}}publisher,{{end}}
        {{ if .IsSubscriber}}subscriber,{{end}}
    ), nil
}
{{- end}}

type {{. | goID}}{{.Protocol | goID}} struct {
    address    {{goPkgRun}}ParamString
    {{if .IsPublisher}}publisher  {{goPkgUtil .Protocol}}Publisher{{end}}
    {{if .IsSubscriber}}subscriber {{goPkgUtil .Protocol}}Subscriber{{end}}
}


{{block "code/proto/channel/commonMethods" .}}
func (c {{. | goID}}{{.Protocol | goID}}) Address() {{goPkgRun}}ParamString {
    return c.address
}

{{- if .BindingsProtocols | has .Protocol}}
func (c {{. | goID}}{{.Protocol | goID}}) Bindings() {{goPkgUtil .Protocol}}ChannelBindings {
    return {{goPkg .Channel}}{{goID .Channel}}Bindings{}.{{.Protocol | goID}}()
}
{{- end}}

func (c {{. | goID}}{{.Protocol | goID}}) Close() (err error) {
    {{- if .IsPublisher}}
        if c.publisher != nil {
            err = {{goPkgExt "errors"}}Join(err, c.publisher.Close())
        }
    {{- end}}
    {{- if .IsSubscriber}}
        if c.subscriber != nil {
            err = {{goPkgExt "errors"}}Join(err, c.subscriber.Close())
        }
    {{- end}}
    return
}
{{- end}}


{{if .IsPublisher}}{{block "code/proto/channel/publishMethods" .}}
type {{ .Channel | goID }}EnvelopeMarshaler{{.Protocol | goID}} interface {
    Marshal{{.Channel | goID}}{{.Protocol | goID}}(envelope {{goPkgUtil .Protocol}}EnvelopeWriter) error
}

{{- range .BoundMessages}}
    {{- if not (isVisible .) }}{{continue}}{{end}}
    func (c {{$ | goID}}{{$.Protocol | goID}}) Seal{{. | goID}}(
        envelope {{goPkgUtil $.Protocol}}EnvelopeWriter,
        message {{ $.Channel | goID }}EnvelopeMarshaler{{$.Protocol | goID}},
    ) error {
        if err := message.Marshal{{$.Channel | goID}}{{$.Protocol | goID}}(envelope); err != nil {
            return err
        }
        {{ with tryTmpl (print "code/proto/" $.Protocol "/channel/publishMethods/block1") .}}{{.}}{{end}}
        {{- if .BindingsProtocols | has $.Protocol }}
            envelope.SetBindings({{goPkg $.Channel}}{{goID $.Channel}}Bindings{}.{{$.Protocol | goID}}())
        {{- end}}
        return nil
    }

    func (c {{$ | goID}}{{$.Protocol | goID}}) Publish{{. | goID}}(
        ctx {{goPkgExt "context"}}Context,
        {{if not (impl $.Protocol)}}envelope {{goPkgUtil $.Protocol}}EnvelopeWriter,{{end}}
        message {{ $.Channel | goID }}EnvelopeMarshaler{{$.Protocol | goID}},
    ) error {
        {{- if impl $.Protocol}}
            envelope := {{goPkgImpl $.Protocol}}NewEnvelopeOut(nil)
        {{- end}}
        if err := c.Seal{{. | goID}}(envelope, message); err != nil {
            return err
        }
        {{ with tryTmpl (print "code/proto/" $.Protocol "/channel/publishMethods/block2") .}}{{.}}{{end}}
        return c.Publish(ctx, envelope)
    }
{{- end}}

func (c {{. | goID}}{{.Protocol | goID}}) Publisher() {{goPkgUtil .Protocol}}Publisher {
    return c.publisher
}

func (c {{. | goID}}{{.Protocol | goID}}) Publish(ctx {{goPkgExt "context"}}Context, envelopes ...{{goPkgUtil .Protocol}}EnvelopeWriter) error {
    return c.publisher.Send(ctx, envelopes...)
}
{{- end}}{{end}}


{{if .IsSubscriber}}{{block "code/proto/channel/subscribeMethods" .}}
type {{ .Channel | goID }}EnvelopeUnmarshaler{{.Protocol | goID}} interface {
    Unmarshal{{.Channel | goID}}{{.Protocol | goID}}(envelope {{goPkgUtil .Protocol}}EnvelopeReader) error
}

{{- range .BoundMessages}}
    {{- if not (isVisible .) }}{{continue}}{{end}}
    func (c {{$ | goID}}{{$.Protocol | goID}}) Unseal{{. | goID}}(
        envelope {{goPkgUtil $.Protocol}}EnvelopeReader,
        message {{ $.Channel | goID }}EnvelopeUnmarshaler{{$.Protocol | goID}},
    ) error {
        return message.Unmarshal{{$.Channel | goID}}{{$.Protocol | goID}}(envelope)
    }

    func (c {{$ | goID}}{{$.Protocol | goID}}) Subscribe{{. | goID}}(
        ctx {{goPkgExt "context"}}Context,
        cb func(message {{ goPkg .InType}}{{ goID .}}Receiver),
    ) (err error) {
        subCtx, cancel := {{goPkgExt "context"}}WithCancel(ctx)
        defer cancel()

        subErr := c.Subscribe(subCtx, func(envelope {{goPkgUtil $.Protocol}}EnvelopeReader) {
            message := new({{ .InType | goUsage }})
            if err2 := c.Unseal{{. | goID}}(envelope, message); err2 != nil {
                err = {{goPkgExt "fmt"}}Errorf("%w: %w", {{goPkgRun}}ErrUnsealEnvelope, err2)
                cancel()
                return
            }
            cb(message)
        })
        if err != nil {
            return err
        }
        return subErr
    }
{{- end}}

func (c {{. | goID}}{{.Protocol | goID}}) Subscriber() {{goPkgUtil .Protocol}}Subscriber {
    return c.subscriber
}

func (c {{. | goID}}{{.Protocol | goID}}) Subscribe(ctx {{goPkgExt "context"}}Context, cb func(envelope {{goPkgUtil .Protocol}}EnvelopeReader)) error {
    return c.subscriber.Receive(ctx, cb)
}
{{- end}}{{end}}
