import (
	"context"
	"errors"
	"fmt"

	"github.com/rabbitmq/amqp091-go"
)

func NewClient(serverURL string, bindings *{{goQualU "amqp" "ServerBindings"}}, security {{goQualR "AnySecurityScheme"}}) (*Client, error) {
	var conn *amqp091.Connection
	var err error

	switch s:=security.(type) {
	case {{goQualR "UserPasswordSecurity"}}:
		user, pass := s.UserPassword()
		amqpAuth := &amqp091.PlainAuth{
			Username: user,
			Password: pass,
		}
		conn, err = amqp091.DialConfig(serverURL, amqp091.Config{
			SASL: []amqp091.Authentication{amqpAuth},
		})
	//case run.X509Security:
	//	tlsConfig := &tls.Config{
	//		Certificates: []tls.Certificate{s.TLSCert()},
	//		ClientAuth: tls.RequireAndVerifyClientCert,
	//	}
	//	conn, err = amqp091.DialTLS_ExternalAuth(serverURL, tlsConfig)
	case nil:
		conn, err = amqp091.Dial(serverURL)
	default:
		return nil, fmt.Errorf("unsupported security scheme %T", security.AuthType())
	}
	if err != nil {
		return nil, err
	}
	return &Client{
		Connection: conn,
		bindings:   bindings,
	}, nil
}

type Client struct {
	*amqp091.Connection
	bindings *{{goQualU "amqp" "ServerBindings"}}
}

func (c Client) Publisher(_ context.Context, _ string, chb *{{goQualU "amqp" "ChannelBindings"}}, opb *{{goQualU "amqp" "OperationBindings"}}, security {{goQualR "AnySecurityScheme"}}) ({{goQualU "amqp" "Publisher"}}, error) {
	if security != nil {
		return nil, fmt.Errorf("security schemes for publishers are not supported")
	}
	ch, err := c.Channel()
	if err != nil {
		return nil, err
	}

	var exchangeName string // By default, publish to the default exchange with empty name
	if chb != nil {
		ec := chb.ExchangeConfiguration
		if ec.Name != nil {
			exchangeName = *ec.Name
		}
		declare := ec.Type != "" || ec.Durable != nil || ec.AutoDelete != nil || ec.VHost != ""
		if declare {
			err = ch.ExchangeDeclare(
				exchangeName,
				string(ec.Type),
                {{goQualR "FromPtrOrZero"}}(ec.Durable),
                {{goQualR "FromPtrOrZero"}}(ec.AutoDelete),
				false,
				false,
				nil,
			)
			if err != nil {
				err = errors.Join(err, ch.Close())
				return nil, fmt.Errorf("exchange declare: %w", err)
			}
		}
	}
	return &PublishChannel{
		Channel:         ch,
		exchangeName:    exchangeName,
		channelBindings: chb,
		operationBindings: opb,
	}, nil
}

func (c Client) Subscriber(_ context.Context, address string, chb *{{goQualU "amqp" "ChannelBindings"}}, opb *{{goQualU "amqp" "OperationBindings"}}, security {{goQualR "AnySecurityScheme"}}) ({{goQualU "amqp" "Subscriber"}}, error) {
	if security != nil {
		return nil, fmt.Errorf("security schemes for subscribers are not supported")
	}
	ch, err := c.Channel()
	if err != nil {
		return nil, err
	}

	// queueName==channelBindings.QueueConfiguration.Name or address
	// exchangeName==channelBindings.ExchangeConfiguration.Name or empty (i.e. default AMQP exchange)
	// If queue.is=="routingKey" (default), then routingKey=address
	// If queue.is=="queue", then routingKey="#"
	exchangeName := amqp091.DefaultExchange
	routingKey := address
	queueName := address
	var durable, autoDelete, exclusive bool
	if chb != nil {
		if chb.ChannelType == {{goQualU "amqp" "ChannelTypeQueue"}} {
			routingKey = "#" // Receive all messages
		}
		qc := chb.QueueConfiguration
		if qc.Name != "" {
			queueName = qc.Name
		}
		durable, autoDelete, exclusive = {{goQualR "FromPtrOrZero"}}(qc.Durable), {{goQualR "FromPtrOrZero"}}(qc.AutoDelete), {{goQualR "FromPtrOrZero"}}(qc.Exclusive)
		exchangeName = {{goQualR "FromPtrOrZero"}}(chb.ExchangeConfiguration.Name)
	}
	if exchangeName == amqp091.DefaultExchange {
		_, err = ch.QueueDeclare(queueName, durable, autoDelete, exclusive, false, nil)
		if err != nil {
			return nil, errors.Join(fmt.Errorf("queue declare: %w", err), ch.Close())
		}
	} else {
		// TODO: binding key in x- schema argument
		if err = ch.QueueBind(queueName, routingKey, exchangeName, false, nil); err != nil {
			return nil, errors.Join(fmt.Errorf("queue bind: %w", err), ch.Close())
		}
	}

	return &SubscribeChannel{
		Channel:         ch,
		queueName:       queueName,
		channelBindings: chb,
		operationBindings: opb,
	}, nil
}
