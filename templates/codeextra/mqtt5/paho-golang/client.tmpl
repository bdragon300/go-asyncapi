import (
	"context"
	"fmt"
	"net/url"
	"sync"

	"github.com/eclipse/paho.golang/autopaho"
	"github.com/eclipse/paho.golang/paho"
)

func NewClient(ctx context.Context, serverURL string, bindings *{{goPkgUtil "mqtt5"}}ServerBindings, security {{goPkgRun}}AnySecurityScheme, initClientConfig *autopaho.ClientConfig) (*Client, error) {
	co := initClientConfig
	if co == nil {
		co = &autopaho.ClientConfig{}
	}

	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, fmt.Errorf("parse serverURL: %w", err)
	}
	co.ServerUrls = append(co.ServerUrls, u)

	if bindings != nil {
		co.ClientID = bindings.ClientID
		co.CleanStartOnInitialConnection = bindings.CleanSession
		if bindings.LastWill != nil {
			co.WillMessage = &paho.WillMessage{
				Topic:   bindings.LastWill.Topic,
				Payload: []byte(bindings.LastWill.Message),
				QoS:     byte(bindings.LastWill.QoS),
				Retain:  bindings.LastWill.Retain,
			}
		}
		if bindings.KeepAlive != 0 {
			co.KeepAlive = uint16(bindings.KeepAlive.Seconds())
		}
		if bindings.SessionExpiryInterval != 0 {
			co.SessionExpiryInterval = uint32(bindings.SessionExpiryInterval.Seconds())
		}
		// TODO: MaximumPacketSize
	}

	if security != nil {
		if err := applySecurity(co, security); err != nil {
			return nil, err
		}
	}

	conn, err := autopaho.NewConnection(ctx, *co)
	if err != nil {
		return nil, fmt.Errorf("new connection: %w", err)
	}

	if err = conn.AwaitConnection(ctx); err != nil {
		return nil, fmt.Errorf("await connection: %w", err)
	}

	return &Client{
		ConnectionManager: conn,
		bindings:          bindings,
	}, nil
}

type Client struct {
	*autopaho.ConnectionManager
	bindings *{{goPkgUtil "mqtt5"}}ServerBindings
}

func (c Client) Publisher(_ context.Context, address string, _ *{{goPkgUtil "mqtt5"}}ChannelBindings, opb *{{goPkgUtil "mqtt5"}}OperationBindings, security {{goPkgRun}}AnySecurityScheme) ({{goPkgUtil "mqtt5"}}Publisher, error) {
	if security != nil {
		return nil, fmt.Errorf("publisher security not supported")
	}

	pubCtx, cancel := context.WithCancel(context.Background())
	return &PublishChannel{
		Conn:              c.ConnectionManager,
		Topic:             address,
		operationBindings: opb,
		ctx:               pubCtx,
		cancel:            cancel,
	}, nil
}

func (c Client) Subscriber(ctx context.Context, address string, _ *{{goPkgUtil "mqtt5"}}ChannelBindings, opb *{{goPkgUtil "mqtt5"}}OperationBindings, security {{goPkgRun}}AnySecurityScheme) ({{goPkgUtil "mqtt5"}}Subscriber, error) {
	if security != nil {
		return nil, fmt.Errorf("subscriber security not supported")
	}

	sub := paho.SubscribeOptions{Topic: address}
	if opb != nil {
		sub.QoS = byte(opb.QoS)
	}

	_, err := c.Subscribe(ctx, &paho.Subscribe{
		Subscriptions: []paho.SubscribeOptions{sub},
	})
	if err != nil {
		return nil, fmt.Errorf("subscribe: %w", err)
	}

	subCtx, cancel := context.WithCancel(context.Background())
	return &SubscribeChannel{
		Conn:   c.ConnectionManager,
		Topic:  address,
		mu:     &sync.Mutex{},
		ctx:    subCtx,
		cancel: cancel,
	}, nil
}

func applySecurity(co *autopaho.ClientConfig, security {{goPkgRun}}AnySecurityScheme) error {
	switch v := security.(type) {
	case {{goPkgRun}}UserPasswordSecurity:
		u, p := v.UserPassword()
		co.ConnectUsername = u
		co.ConnectPassword = []byte(p)
		return nil
	case {{goPkgRun}}APIKeySecurity:
		co.ConnectPassword = []byte(v.APIKey())
		return nil
	}

	return fmt.Errorf("unsupported security scheme: %v", security.AuthType())
}
