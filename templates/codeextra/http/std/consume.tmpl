import (
	"context"
	"fmt"
	stdHTTP "net/http" {{/* Import alias to avoid conflict with generated package name */}}
	"strings"
	"sync"
)

func NewConsumer(bindings *{{goPkgUtil "http"}}ServerBindings, security {{goPkgRun}}AnySecurityScheme) *ConsumeClient {
	return &ConsumeClient{
		bindings:    bindings,
		mu:          &sync.RWMutex{},
		subscribers: make(map[string]*{{goPkgRun}}Ring[subscriberFunc]),
		security:    security,
	}
}

type subscriberFunc func(envelope {{goPkgUtil "http"}}EnvelopeReader)

type ConsumeClient struct {
	stdHTTP.ServeMux
	bindings *{{goPkgUtil "http"}}ServerBindings
	security {{goPkgRun}}AnySecurityScheme
	mu       *sync.RWMutex
	// subscribers are callbacks list by channel name.
	subscribers map[string]*{{goPkgRun}}Ring[subscriberFunc]
}

func (c *ConsumeClient) Subscriber(_ context.Context, address string, chb *{{goPkgUtil "http"}}ChannelBindings, opb *{{goPkgUtil "http"}}OperationBindings, security {{goPkgRun}}AnySecurityScheme) ({{goPkgUtil "http"}}Subscriber, error) {
	c.mu.Lock()
	defer c.mu.Unlock()

	s := c.security
	if security != nil {
		s = security
	}
	// Because of the HTTP server implementation, we can't change HTTP handler once it has been registered.
	// So, here the bindings and security are used only on the first subscription for a channel, they are
	// ignored on subsequent subscription calls for this channel even if different.
	c.ensureChannel(address, opb, s)
	subscriber := &SubscribeChannel{
		channelBindings:   chb,
		operationBindings: opb,
		security:          security,
		callbacks:         c.subscribers[address],
	}

	return subscriber, nil
}

func (c *ConsumeClient) ensureChannel(channelName string, opb *{{goPkgUtil "http"}}OperationBindings, sec {{goPkgRun}}AnySecurityScheme) {
	if _, ok := c.subscribers[channelName]; !ok {
		c.subscribers[channelName] = {{goPkgRun}}NewRing[subscriberFunc]()
		c.HandleFunc(channelName, func(w stdHTTP.ResponseWriter, req *stdHTTP.Request) {
			if opb != nil {
				needMethod := opb.Method
				if needMethod != "" && strings.ToUpper(needMethod) != req.Method {
					stdHTTP.Error(w, "method not allowed", stdHTTP.StatusMethodNotAllowed)
					return
				}
			}

			if sec != nil {
				authOk, err := c.checkSecurity(req, sec)
				if err != nil {
					stdHTTP.Error(w, "internal server error", stdHTTP.StatusInternalServerError)
					return
				}
				if !authOk {
					stdHTTP.Error(w, "unauthorized", stdHTTP.StatusUnauthorized)
					return
				}
			}

			c.mu.RLock()
			defer c.mu.RUnlock()
			if _, ok := c.subscribers[channelName]; !ok {
				stdHTTP.Error(w, "channel not found", stdHTTP.StatusNotFound)
				return
			}
			cb, ok := c.subscribers[channelName].Next()
			if !ok {
				stdHTTP.Error(w, "no subscribers", stdHTTP.StatusServiceUnavailable)
				return
			}
			cb(NewEnvelopeIn(req, w))
		})
	}
}

func (c *ConsumeClient) checkSecurity(req *stdHTTP.Request, sec {{goPkgRun}}AnySecurityScheme) (bool, error) {
	uUser, uPass, ok := req.BasicAuth()
    if !ok {
        return false, nil // No auth provided
    }

	switch v := sec.(type) {
	case {{goPkgRun}}UserPasswordSecurity:
		user, pass := v.UserPassword()
		return uUser == user && uPass == pass, nil
	case {{goPkgRun}}APIKeySecurity:
		key := v.APIKey()
		switch v.In() {
		case "user":
			return uUser == key, nil
		case "password":
			return uPass == key, nil
		}
	}

	return false, fmt.Errorf("unsupported security scheme: %v", sec.AuthType())
}