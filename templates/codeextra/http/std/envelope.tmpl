import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"net/http"
)

func NewEnvelopeOut() *EnvelopeOut {
	req := &http.Request{ // Taken from http.NewRequestWithContext
		Method:     "GET",
		Proto:      "HTTP/1.1",
		ProtoMajor: 1,
		ProtoMinor: 1,
		Header:     make(http.Header),
	}
	return &EnvelopeOut{
		Request: req.WithContext(context.Background()),
		body:    bytes.NewBuffer(make([]byte, 0)),
	}
}

type EnvelopeOut struct {
	*http.Request
	messageBindings {{goQualU "http" "MessageBindings"}}
	body            *bytes.Buffer
}

func (e *EnvelopeOut) Write(p []byte) (n int, err error) {
	return e.body.Write(p)
}

func (e *EnvelopeOut) Read(p []byte) (n int, err error) {
	return e.body.Read(p)
}

func (e *EnvelopeOut) ResetPayload() {
	e.body.Reset()
}

func (e *EnvelopeOut) SetHeaders(headers {{goQualR "Headers"}}) {
	for name, value := range headers {
		switch v := value.(type) {
		case string:
			e.Header.Set(name, v)
		case []byte:
			e.Header.Set(name, string(v))
		case fmt.Stringer:
			e.Header.Set(name, v.String())
		case []string:
			e.Header.Del(name)
			for _, item := range v {
				e.Header.Add(name, item)
			}
		default:
			panic(fmt.Sprintf("Header value can be string, []byte, fmt.Stringer, []string; got: %T", value))
		}
	}
}

func (e *EnvelopeOut) SetContentType(contentType string) {
	e.Header.Set("Content-Type", contentType)
}

func (e *EnvelopeOut) SetBindings(bindings {{goQualU "http" "MessageBindings"}}) {
	e.messageBindings = bindings
}

func (e *EnvelopeOut) AsStdRecord() *http.Request {
	reqCopy := e.Request.Clone(context.Background())
	reqCopy.Body = io.NopCloser(e.body)
	reqCopy.ContentLength = int64(e.body.Len())
	reqCopy.GetBody = func() (io.ReadCloser, error) {
		snapshot := e.body.Bytes()
		return io.NopCloser(bytes.NewReader(snapshot)), nil
	}
	return reqCopy
}

func NewEnvelopeIn(req *http.Request, responseWriter http.ResponseWriter) *EnvelopeIn {
	return &EnvelopeIn{Request: req, ResponseWriter: responseWriter}
}

type EnvelopeIn struct {
	*http.Request
	ResponseWriter http.ResponseWriter
}

func (e *EnvelopeIn) Read(p []byte) (n int, err error) {
	n, err = e.Request.Body.Read(p)
	if errors.Is(err, io.EOF) {
		_ = e.Request.Body.Close()
	}
	return
}

func (e *EnvelopeIn) Headers() {{goQualR "Headers"}} {
	res := make({{goQualR "Headers"}})
	for name, val := range e.Request.Header {
		res[name] = val
	}
	return res
}
