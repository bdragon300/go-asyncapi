import (
	"bytes"
	"io"

	natsGo "github.com/nats-io/nats.go" {{/* Import alias to avoid conflict with generated package name */}}
)

func NewEnvelopeOut(buf []byte) *EnvelopeOut {
    m := natsGo.NewMsg("")
    m.Data = buf
    return &EnvelopeOut{Msg: m}
}

type EnvelopeOut struct {
	*natsGo.Msg
	messageBindings {{goPkgUtil "nats"}}MessageBindings
}

func (e *EnvelopeOut) Write(p []byte) (n int, err error) {
	e.Data = append(e.Data, p...)
	return len(p), nil
}

func (e *EnvelopeOut) ResetPayload() {
	e.Data = e.Data[:0]
}

func (e *EnvelopeOut) SetHeaders(headers {{goPkgRun}}Headers) {
	if e.Header == nil {
		e.Header = natsGo.Header{}
	}
	for k, v := range headers.ToByteValues() {
		e.Header.Set(k, string(v))
	}
}

func (e *EnvelopeOut) SetContentType(contentType string) {
	if e.Header == nil {
		e.Header = natsGo.Header{}
	}
	e.Header.Set("Content-Type", contentType)
}

func (e *EnvelopeOut) SetBindings(bindings {{goPkgUtil "nats"}}MessageBindings) {
	e.messageBindings = bindings
}

func (e *EnvelopeOut) SetSubject(subject string) {
	e.Subject = subject
}

func NewEnvelopeIn(msg *natsGo.Msg) *EnvelopeIn {
	return &EnvelopeIn{
		Msg: msg,
		rd:  bytes.NewReader(msg.Data),
	}
}

type EnvelopeIn struct {
	*natsGo.Msg
	rd io.Reader
}

func (e *EnvelopeIn) Read(p []byte) (n int, err error) {
	return e.rd.Read(p)
}

func (e *EnvelopeIn) Headers() {{goPkgRun}}Headers {
	if e.Header == nil {
		return {{goPkgRun}}Headers{}
	}
	hdrs := make({{goPkgRun}}Headers, len(e.Header))
	for k, v := range e.Header {
		if len(v) > 0 {
			hdrs[k] = []byte(v[0])
		}
	}
	return hdrs
}
