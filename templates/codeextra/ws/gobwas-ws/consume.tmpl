import (
	"bufio"
	"context"
	"fmt"
	"net"
	"net/http"
	"strings"
	"sync"

	wsclient "github.com/gobwas/ws"
	"github.com/gobwas/ws/wsutil"
)

// TODO: remove httpResponseTimeout, allow to use smth like http.requestHandler or nothing
func NewConsumer(bindings *{{goPkgUtil "ws"}}ServerBindings, security {{goPkgRun}}AnySecurityScheme) *ConsumeClient {
	return &ConsumeClient{
		Upgrader:    wsclient.DefaultHTTPUpgrader,
		bindings:    bindings,
		security:    security,
		connections: make(map[string]chan *Channel),
		mu:          new(sync.RWMutex),
	}
}

type HTTPUpgraderInterface interface {
	Upgrade(r *http.Request, w http.ResponseWriter) (conn net.Conn, rw *bufio.ReadWriter, hs wsclient.Handshake, err error)
}

type ConsumeClient struct {
	http.ServeMux
	Upgrader    HTTPUpgraderInterface
	bindings    *{{goPkgUtil "ws"}}ServerBindings
	security    {{goPkgRun}}AnySecurityScheme
	connections map[string]chan *Channel
	mu          *sync.RWMutex
}

func (c *ConsumeClient) Subscriber(ctx context.Context, address string, chb *{{goPkgUtil "ws"}}ChannelBindings, opb *{{goPkgUtil "ws"}}OperationBindings, security {{goPkgRun}}AnySecurityScheme) ({{goPkgUtil "ws"}}Subscriber, error) {
	sec := c.security
	if security != nil {
		sec = security
	}

	c.ensureChannel(address, chb, opb, sec) // FIXME: maybe it's better to take the path from bindings?
	// Wait for a new connection
	select {
	case <-ctx.Done():
		return nil, ctx.Err()
	case conn := <-c.connections[address]:
		return conn, nil
	}
}

func (c *ConsumeClient) ensureChannel(channelName string, chb *{{goPkgUtil "ws"}}ChannelBindings, opb *{{goPkgUtil "ws"}}OperationBindings, sec {{goPkgRun}}AnySecurityScheme) {
	c.mu.Lock()
	defer c.mu.Unlock()

	if _, ok := c.connections[channelName]; !ok { // HandleFunc panics if called more than once for the same channel
		c.connections[channelName] = make(chan *Channel)
		c.HandleFunc(channelName, func(w http.ResponseWriter, req *http.Request) {
			if chb != nil {
				needMethod := chb.Method
				if needMethod != "" && strings.ToUpper(needMethod) != req.Method {
					http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
					return
				}
			}

			if sec != nil {
				authOk, err := c.checkSecurity(req, sec)
				if err != nil {
					http.Error(w, "internal server error", http.StatusInternalServerError)
					return
				}
				if !authOk {
					http.Error(w, "unauthorized", http.StatusUnauthorized)
					return
				}
			}

			c.mu.RLock()
			defer c.mu.RUnlock()
			if _, ok := c.connections[channelName]; !ok {
				http.Error(w, "channel not found", http.StatusNotFound)
				return
			}

			netConn, _, _, err := c.Upgrader.Upgrade(req, w)
			if err != nil {
				// TODO: error log
				http.Error(w, "internal server error", http.StatusInternalServerError)
				return
			}

			conn := NewChannel(chb, opb, netConn, false)
			select {
			case <-req.Context().Done():
				// TODO: error log
				defer conn.Close()
				_ = wsutil.WriteServerMessage(netConn, wsclient.OpClose, []byte("connection closed"))
			case c.connections[channelName] <- conn:
			}
		})
	}
}

func (c *ConsumeClient) checkSecurity(req *http.Request, sec {{goPkgRun}}AnySecurityScheme) (bool, error) {
	uUser, uPass, ok := req.BasicAuth()
	if !ok {
		return false, nil // No auth provided
	}

	switch v := sec.(type) {
	case {{goPkgRun}}UserPasswordSecurity:
		user, pass := v.UserPassword()
		return uUser == user && uPass == pass, nil
	case {{goPkgRun}}APIKeySecurity:
		key := v.APIKey()
		switch v.In() {
		case "user":
			return uUser == key, nil
		case "password":
			return uPass == key, nil
		}
	}

	return false, fmt.Errorf("unsupported security scheme: %v", sec.AuthType())
}
