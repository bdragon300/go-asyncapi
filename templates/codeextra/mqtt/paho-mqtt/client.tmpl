import (
	"context"
	"fmt"

	mqtt "github.com/eclipse/paho.mqtt.golang"
)

func NewClient(ctx context.Context, serverURL string, bindings *{{goPkgUtil "mqtt"}}ServerBindings, security {{goPkgRun}}AnySecurityScheme, initClientOptions *mqtt.ClientOptions) (*Client, error) {
	co := initClientOptions
	if co == nil {
		co = mqtt.NewClientOptions()
	}

	co.AddBroker(serverURL)
	if bindings != nil {
		co.SetCleanSession(bindings.CleanSession)
		if bindings.ClientID != "" {
			co.SetClientID(bindings.ClientID)
		}
		if bindings.KeepAlive != 0 {
			co.SetKeepAlive(bindings.KeepAlive)
		}
		if bindings.LastWill != nil {
			co.SetWill(bindings.LastWill.Topic, bindings.LastWill.Message, byte(bindings.LastWill.QoS), bindings.LastWill.Retain)
		}
	}

	if security != nil {
		if err := applySecurity(co, security); err != nil {
			return nil, err
		}
	}

	cl := mqtt.NewClient(co)
	tok := cl.Connect()
	select {
	case <-ctx.Done():
		return nil, ctx.Err()
	case <-tok.Done():
		if tok.Error() != nil {
			return nil, tok.Error()
		}
	}

	return &Client{
		Client:   cl,
		bindings: bindings,
	}, nil
}

type Client struct {
	mqtt.Client
	bindings *{{goPkgUtil "mqtt"}}ServerBindings
}

func (c *Client) Subscriber(ctx context.Context, address string, chb *{{goPkgUtil "mqtt"}}ChannelBindings, opb *{{goPkgUtil "mqtt"}}OperationBindings, security {{goPkgRun}}AnySecurityScheme) ({{goPkgUtil "mqtt"}}Subscriber, error) {
	if security != nil {
		return nil, fmt.Errorf("subscriber security not supported")
	}

	var qos byte
	if opb != nil {
		qos = byte(opb.QoS)
	}

	ch := make(chan {{goPkgUtil "mqtt"}}EnvelopeReader)
	tok := c.Client.Subscribe(address, qos, func(_ mqtt.Client, message mqtt.Message) {
		ch <- NewEnvelopeIn(message)
	})
	select {
	case <-ctx.Done():
		return nil, ctx.Err()
	case <-tok.Done():
		if tok.Error() != nil {
			return nil, tok.Error()
		}
	}

	ctx2, cancel := context.WithCancel(context.Background())
	r := SubscribeChannel{
		Client:            c.Client,
		Topic:             address,
		channelBindings:   chb,
		operationBindings: opb,
		envelopes:         ch,
		ctx:               ctx2,
		cancel:            cancel,
	}
	return &r, nil
}

func (c *Client) Publisher(_ context.Context, address string, chb *{{goPkgUtil "mqtt"}}ChannelBindings, opb *{{goPkgUtil "mqtt"}}OperationBindings, security {{goPkgRun}}AnySecurityScheme) ({{goPkgUtil "mqtt"}}Publisher, error) {
	if security != nil {
		return nil, fmt.Errorf("publisher security not supported")
	}

	ctx2, cancel := context.WithCancel(context.Background())
	r := PublishChannel{
		Client:            c.Client,
		Topic:             address,
		channelBindings:   chb,
		operationBindings: opb,
		ctx:               ctx2,
		cancel:            cancel,
	}
	return &r, nil
}

func applySecurity(co *mqtt.ClientOptions, sec {{goPkgRun}}AnySecurityScheme) error {
	switch v := sec.(type) {
	case {{goPkgRun}}UserPasswordSecurity:
		u, p := v.UserPassword()
		co.SetUsername(u)
		co.SetPassword(p)
		return nil
	}

	return fmt.Errorf("unsupported security scheme: %v", sec.AuthType())
}
