import (
	"context"
	"errors"
	"fmt"

	"github.com/bdragon300/go-asyncapi/run"
	runKafka "github.com/bdragon300/go-asyncapi/run/kafka"

	"github.com/twmb/franz-go/pkg/kgo"
)

func NewConsumer(hosts []string, bindings *runKafka.ServerBindings, security run.AnySecurityScheme, extraOpts ...kgo.Opt) *ConsumeClient {
	return &ConsumeClient{
		hosts:     hosts,
		bindings:  bindings,
		extraOpts: extraOpts,
	}
}

type ConsumeClient struct {
	hosts    []string
	bindings *runKafka.ServerBindings
	extraOpts []kgo.Opt
}

func (c ConsumeClient) Subscriber(_ context.Context, address string, chb *runKafka.ChannelBindings, opb *runKafka.OperationBindings, security run.AnySecurityScheme) (runKafka.Subscriber, error) {
	// TODO: schema registry https://github.com/twmb/franz-go/blob/master/examples/schema_registry/schema_registry.go
	// TODO: chb.ClientID, chb.GroupID
	var opts []kgo.Opt

	opts = append(opts, kgo.SeedBrokers(c.hosts...))

	topic := address
	if chb != nil && chb.Topic != "" {
		topic = chb.Topic
	}
	if topic != "" {
		opts = append(opts, kgo.ConsumeTopics(topic))
	}
	opts = append(opts, c.extraOpts...)

	cl, err := kgo.NewClient(opts...)
	if err != nil {
		return nil, err
	}

	return &SubscribeChannel{
		Client:          cl,
		Topic:           topic,
		channelBindings: chb,
		operationBindings: opb,
	}, nil
}

type SubscribeChannel struct {
	*kgo.Client
	Topic             string
	IgnoreFetchErrors bool // TODO: add opts for Subscriber/Publisher interfaces
	channelBindings *runKafka.ChannelBindings
	operationBindings *runKafka.OperationBindings
}

func (s SubscribeChannel) Receive(ctx context.Context, cb func(envelope runKafka.EnvelopeReader)) error {
	for {
		fetches := s.Client.PollFetches(ctx)
		if fetches.Err0() != nil {
			return fetches.Err0()
		}
		var batchError error

		if !s.IgnoreFetchErrors {
			fetches.EachError(func(topic string, partition int32, err error) {
				batchError = errors.Join(batchError, fmt.Errorf("topic=%q, partition=%v: %w", topic, partition, err))
			})
		}
		if batchError != nil {
			return fmt.Errorf("fetch errors: %w", batchError)
		}

		fetches.EachRecord(func(r *kgo.Record) {
			select {
			case <-ctx.Done():
			default:
				cb(NewEnvelopeIn(r))
			}
		})
	}
}

func (s SubscribeChannel) Close() error {
	s.Client.Close()
	return nil
}
