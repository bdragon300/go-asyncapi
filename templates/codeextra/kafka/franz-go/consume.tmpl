import (
	"context"
	"errors"
	"fmt"

	"github.com/twmb/franz-go/pkg/kgo"
	"github.com/twmb/franz-go/pkg/sasl"
)

func NewConsumer(hosts []string, bindings *{{goPkgUtil "kafka"}}ServerBindings, security {{goPkgRun}}AnySecurityScheme, extraOpts ...kgo.Opt) *ConsumeClient {
	return &ConsumeClient{
		hosts:     hosts,
		bindings:  bindings,
		extraOpts: extraOpts,
		security:  security,
	}
}

type ConsumeClient struct {
	hosts     []string
	bindings  *{{goPkgUtil "kafka"}}ServerBindings
	extraOpts []kgo.Opt
	security  {{goPkgRun}}AnySecurityScheme
}

func (c ConsumeClient) Subscriber(_ context.Context, address string, chb *{{goPkgUtil "kafka"}}ChannelBindings, opb *{{goPkgUtil "kafka"}}OperationBindings, security {{goPkgRun}}AnySecurityScheme) ({{goPkgUtil "kafka"}}Subscriber, error) {
	// TODO: schema registry https://github.com/twmb/franz-go/blob/master/examples/schema_registry/schema_registry.go
	// TODO: chb.ClientID, chb.GroupID
	var opts []kgo.Opt

	opts = append(opts, kgo.SeedBrokers(c.hosts...))

	var saslMech []sasl.Mechanism
	for _, sec := range []{{goPkgRun}}AnySecurityScheme{c.security, security} {
		if sec == nil {
			continue
		}
		mech, err := toSaslMechanism(sec)
		if err != nil {
			return nil, err
		}
		saslMech = append(saslMech, mech)
	}
	if len(saslMech) > 0 {
		opts = append(opts, kgo.SASL(saslMech...))
	}

	topic := address
	if chb != nil && chb.Topic != "" {
		topic = chb.Topic
	}
	if topic != "" {
		opts = append(opts, kgo.ConsumeTopics(topic))
	}
	opts = append(opts, c.extraOpts...)

	cl, err := kgo.NewClient(opts...)
	if err != nil {
		return nil, err
	}

	return &SubscribeChannel{
		Client:            cl,
		Topic:             topic,
		channelBindings:   chb,
		operationBindings: opb,
	}, nil
}

type SubscribeChannel struct {
	*kgo.Client
	Topic             string
	IgnoreFetchErrors bool // TODO: add opts for Subscriber/Publisher interfaces
	channelBindings   *{{goPkgUtil "kafka"}}ChannelBindings
	operationBindings *{{goPkgUtil "kafka"}}OperationBindings
}

func (s SubscribeChannel) Receive(ctx context.Context, cb func(envelope {{goPkgUtil "kafka"}}EnvelopeReader)) error {
	for {
		fetches := s.Client.PollFetches(ctx)
		if fetches.Err0() != nil {
			return fetches.Err0()
		}
		var batchError error

		if !s.IgnoreFetchErrors {
			fetches.EachError(func(topic string, partition int32, err error) {
				batchError = errors.Join(batchError, fmt.Errorf("topic=%q, partition=%v: %w", topic, partition, err))
			})
		}
		if batchError != nil {
			return fmt.Errorf("fetch errors: %w", batchError)
		}

		fetches.EachRecord(func(r *kgo.Record) {
			select {
			case <-ctx.Done():
			default:
				cb(NewEnvelopeIn(r))
			}
		})
	}
}

func (s SubscribeChannel) Close() error {
	s.Client.Close()
	return nil
}
