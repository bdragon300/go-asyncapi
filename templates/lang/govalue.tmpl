{{define "usage"}}
    {{if .Type}}
        {{if .Type.IsPointer}}
            {{if .Empty}}
                {{if .EmptyCurlyBrakets /* &{} -> ToPtr({}) */ }}{{qualrun "ToPtr"}}({}){{else /* &nil -> nil */}}nil{{end}}
            {{else if .LiteralValue}}
                {{$t := unwrapgoptr .Type}}
                {{if $t /* &int(123) -> ToPtr(int(123)) */}}
                    {{qualrun "ToPtr"}}({{$t.U}}({{template "value_expr" .}}))
                {{else /* &123 -> ToPtr(123) */}}
                    {{qualrun "ToPtr"}}({{template "value_expr" .}})
                {{end}}
            {{else /* &AnyType{}; &map[string]int{}; &[]int{} */}}
                &{{.Type.U}}{{if .LiteralValue /* int(123) */}}({{template "value_expr" .}}){{else}}{{template "value_expr" .}}{{end}}
            {{end}}
        {{else}}
            {{.Type.U}}{{if .LiteralValue /* int(123) */}}({{template "value_expr" .}}){{else}}{{template "value_expr" .}}{{end}}
        {{end}}
    {{else}}
        {{template "value_expr" .}}
    {{end}}
{{end}}

{{define "value_expr"}}
    {{if .LiteralValue /* Literal */}}
        {{ .LiteralValue | golit }}
    {{else if .MapValues.Len /* Map */}}
        {
        {{range .MapValues.Entries}}
            {{.Key | golit }}: {{ .Value | golit }},
        {{end}}
        }
    {{else if .StructValues.Len /* Struct */}}
        {
        {{range .StructValues.Entries}}
            {{.Key | goid }}: {{ .Value | golit }},
        {{end}}
        }
    {{else if .ArrayValues /* Array/slice */}}
        {
        {{range .ArrayValues}}
            {{ . | golit }},
        {{end}}
        }
    {{else /*Empty value*/ }}
        {{if .EmptyCurlyBrakets}}{}{{else}}nil{{end}}
    {{end}}
{{end}}