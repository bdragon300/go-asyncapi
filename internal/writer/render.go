package writer

import (
	"bytes"
	"fmt"
	"os"
	"path"

	"github.com/bdragon300/asyncapi-codegen-go/internal/common"
	"github.com/dave/jennifer/jen"
)

const GeneratedCodePreamble = "Code generated by asyncapi-codegen-go tool. DO NOT EDIT."

func RenderPackages(packages map[string]*common.Package, importBase, baseDir string) (files map[string]*jen.File, err error) {
	files = make(map[string]*jen.File)
	logger := common.NewLogger("Rendering üé®")
	counter := 0

	for pkgName, pkg := range packages {
		ctx := &common.RenderContext{
			CurrentPackage: pkgName,
			ImportBase:     importBase,
			Logger:         logger,
		}
		f := jen.NewFilePathName(baseDir, pkgName)
		f.HeaderComment(GeneratedCodePreamble)
		ctx.Logger.Debug("Package", "pkg", pkgName, "items", len(pkg.Items()))
		for _, item := range pkg.Items() {
			counter++
			if !item.Typ.DirectRendering() {
				continue
			}
			for _, stmt := range item.Typ.RenderDefinition(ctx) {
				f.Add(stmt)
			}
			f.Add(jen.Line())
		}

		fileName := pkgName + ".go"
		ctx.Logger.Debug("Package rendered as file", "pkg", pkgName, "file", fileName)
		files[path.Join(pkgName, fileName)] = f
	}
	logger.Info("Finished", "packages", len(packages), "objects", counter)
	return
}

func WriteToFiles(files map[string]*jen.File, baseDir string) error {
	l := common.NewLogger("Writing üìù")

	if err := ensureDir(baseDir); err != nil {
		return err
	}
	buf := &bytes.Buffer{}
	totalBytes := 0
	for fileName, fileObj := range files {
		buf.Reset()
		l.Debug("File", "name", fileName)
		fullPath := path.Join(baseDir, fileName)
		if err := ensureDir(path.Dir(fullPath)); err != nil {
			return err
		}
		if err := fileObj.Render(buf); err != nil {
			return err // TODO: multiline error
		}
		if err := os.WriteFile(fullPath, buf.Bytes(), 0o644); err != nil {
			return err
		}
		l.Debug("File wrote", "name", fullPath, "bytes", buf.Len())
		totalBytes += buf.Len()
	}
	l.Info("Finished", "files", len(files), "total_bytes", totalBytes)
	return nil
}

func ensureDir(path string) error {
	if info, err := os.Stat(path); os.IsNotExist(err) {
		if err2 := os.MkdirAll(path, 0o755); err2 != nil {
			return err2
		}
	} else if err != nil {
		return err
	} else if !info.IsDir() {
		return fmt.Errorf("path %q is not a directory", path)
	}

	return nil
}
